<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ListIQ</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f4f6f9;
      color: #1a1a2e;
      min-height: 100vh;
    }

    header {
      padding: 18px 32px;
      background: #fff;
      border-bottom: 1px solid #e5e7eb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.04);
      display: flex;
      align-items: center;
      gap: 14px;
    }
    header h1 {
      font-size: 24px; font-weight: 800; color: #4f6ef7;
      letter-spacing: -0.5px;
    }
    header span { font-size: 13px; color: #8b8fa3; margin-top: 2px; }

    .container { max-width: 1300px; margin: 0 auto; padding: 32px; }

    /* ══════════════════════════════════════
       Product Input Form
       ══════════════════════════════════════ */
    .input-section {
      background: #fff; border-radius: 16px; padding: 32px;
      border: 1px solid #e5e7eb; box-shadow: 0 1px 4px rgba(0,0,0,0.04);
      margin-bottom: 32px;
    }
    .input-section h2 {
      font-size: 18px; font-weight: 700; color: #1a1a2e; margin-bottom: 20px;
    }
    .input-form {
      display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap;
    }
    .input-field { display: flex; flex-direction: column; gap: 5px; flex: 1; min-width: 200px; }
    .input-field label {
      font-size: 11px; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.5px; color: #8b8fa3;
    }
    .input-field input {
      padding: 10px 14px; border: 1px solid #d1d5db; border-radius: 10px;
      font-size: 14px; outline: none; transition: border-color 0.15s;
      background: #fff; color: #1a1a2e;
    }
    .input-field input:focus { border-color: #4f6ef7; }

    /* Buttons */
    .btn {
      padding: 10px 24px; border: none; border-radius: 10px;
      font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.15s;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn-primary { background: #4f6ef7; color: #fff; }
    .btn-primary:hover { background: #3b5ce4; }
    .btn-primary:disabled { background: #c5cee8; color: #8895b3; cursor: not-allowed; transform: none; }
    .btn-secondary { background: #e9ecef; color: #555b6e; }
    .btn-secondary:hover { background: #dde1e6; }
    .btn-green { background: #22c55e; color: #fff; }
    .btn-green:hover { background: #16a34a; }
    .btn-green:disabled { background: #bbf7d0; color: #86efac; cursor: not-allowed; transform: none; }
    .btn-red { background: #ef4444; color: #fff; }
    .btn-red:hover { background: #dc2626; }
    .btn-red:disabled { background: #fecaca; color: #f87171; cursor: not-allowed; transform: none; }
    .btn-sm { padding: 7px 16px; font-size: 12px; }
    .btn-xs { padding: 5px 12px; font-size: 11px; border-radius: 8px; }

    .status-text { font-size: 13px; color: #8b8fa3; margin-top: 12px; }
    .spinner {
      display: inline-block; width: 16px; height: 16px;
      border: 2px solid #d1d5db; border-top-color: #4f6ef7; border-radius: 50%;
      animation: spin 0.6s linear infinite; margin-right: 8px; vertical-align: middle;
    }
    .spinner-green { border-top-color: #22c55e; }
    .spinner-sm { width: 12px; height: 12px; border-width: 1.5px; margin-right: 5px; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* ══════════════════════════════════════
       Product Table
       ══════════════════════════════════════ */
    .results-section { margin-top: 40px; }

    .results-toolbar {
      display: flex; align-items: center; justify-content: space-between;
      margin-bottom: 16px; flex-wrap: wrap; gap: 12px;
    }
    .results-toolbar h2 { font-size: 18px; font-weight: 700; color: #1a1a2e; }
    .results-toolbar-actions { display: flex; gap: 10px; }

    .product-table {
      width: 100%; border-collapse: separate; border-spacing: 0;
      background: #fff; border-radius: 14px; overflow: hidden;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 4px rgba(0,0,0,0.04);
    }
    .product-table thead th {
      padding: 10px 14px; font-size: 11px; font-weight: 700;
      text-transform: uppercase; letter-spacing: 0.5px;
      color: #8b8fa3; background: #f8f9fb; border-bottom: 1px solid #e5e7eb;
      text-align: left; white-space: nowrap;
    }
    .product-table tbody tr {
      border-bottom: 1px solid #f0f1f3; transition: background 0.15s;
    }
    .product-table tbody tr:hover { background: #f8f9fb; }
    .product-table tbody tr:last-child { border-bottom: none; }
    .product-table tbody td {
      padding: 12px 14px; vertical-align: top; font-size: 13px;
    }

    /* Row states */
    .product-table tbody tr.row-rejected { opacity: 0.35; }
    .product-table tbody tr.row-listed { background: #f0fdf4; }

    /* Product info cell */
    .cell-product-title {
      font-size: 13px; font-weight: 600; color: #1a1a2e;
      margin-bottom: 3px; line-height: 1.3;
      max-width: 260px; overflow: hidden; text-overflow: ellipsis;
      display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
    }
    .cell-product-meta {
      font-size: 11px; color: #8b8fa3; line-height: 1.5;
    }
    .cell-product-meta span { margin-right: 10px; white-space: nowrap; }

    /* Price input */
    .cell-price-input {
      width: 80px; padding: 5px 8px; border: 1px solid #d1d5db;
      border-radius: 8px; background: #fff; color: #1a1a2e;
      font-size: 13px; outline: none; transition: border-color 0.15s;
    }
    .cell-price-input:focus { border-color: #4f6ef7; }

    /* Price range */
    .price-cell-wrap { display: flex; flex-direction: column; gap: 4px; }
    .price-range-btn {
      background: none; border: 1px solid #d1d5db; border-radius: 6px;
      color: #4f6ef7; font-size: 11px; cursor: pointer; padding: 2px 6px;
      white-space: nowrap; transition: all 0.15s;
    }
    .price-range-btn:hover { background: #eef1ff; border-color: #4f6ef7; }
    .price-range-info {
      font-size: 11px; color: #555b6e; line-height: 1.4;
      background: #f0f4ff; border-radius: 6px; padding: 4px 7px;
      min-width: 110px;
    }
    .price-range-info .pr-label { color: #8b8fa3; font-size: 10px; }
    .price-range-info .pr-val { font-weight: 600; color: #1a1a2e; }

    /* Category autocomplete */
    .cat-autocomplete { position: relative; }
    .cat-autocomplete input {
      width: 100%; padding: 7px 10px; border: 1px solid #d1d5db;
      border-radius: 8px; font-size: 13px; outline: none; box-sizing: border-box;
    }
    .cat-autocomplete input:focus { border-color: #4f6ef7; }
    .cat-selected {
      display: flex; align-items: center; gap: 6px;
      background: #eef1ff; border-radius: 6px; padding: 5px 8px; margin-bottom: 6px;
      font-size: 12px; color: #1a1a2e;
    }
    .cat-selected .cat-name { font-weight: 600; }
    .cat-selected .cat-id { color: #8b8fa3; font-size: 11px; }
    .cat-selected .cat-clear {
      margin-left: auto; cursor: pointer; color: #8b8fa3; font-size: 14px;
      border: none; background: none; padding: 0 4px; line-height: 1;
    }
    .cat-selected .cat-clear:hover { color: #ef4444; }
    .cat-dropdown {
      position: absolute; top: 100%; left: 0; right: 0; z-index: 100;
      background: #fff; border: 1px solid #d1d5db; border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.12); max-height: 220px;
      overflow-y: auto; margin-top: 2px; display: none;
    }
    .cat-dropdown.open { display: block; }
    .cat-dropdown-item {
      padding: 8px 10px; cursor: pointer; border-bottom: 1px solid #f0f0f0;
      transition: background 0.1s;
    }
    .cat-dropdown-item:last-child { border-bottom: none; }
    .cat-dropdown-item:hover { background: #eef1ff; }
    .cat-dropdown-item .cat-item-name { font-size: 13px; font-weight: 600; color: #1a1a2e; }
    .cat-dropdown-item .cat-item-path { font-size: 11px; color: #8b8fa3; margin-top: 1px; }
    .cat-dropdown-loading { padding: 10px; text-align: center; color: #8b8fa3; font-size: 12px; }

    /* Condition select */
    .cell-cond-select {
      padding: 5px 6px; border: 1px solid #d1d5db;
      border-radius: 8px; background: #fff; color: #1a1a2e;
      font-size: 12px; outline: none; width: 100%;
      max-width: 130px;
    }
    .cell-cond-select:focus { border-color: #4f6ef7; }

    /* Status badges */
    .badge {
      display: inline-block; font-size: 11px; font-weight: 600;
      padding: 3px 10px; border-radius: 20px; white-space: nowrap;
    }
    .badge-pending { background: #e0ecff; color: #3b6cf7; }
    .badge-generating { background: #fef3c7; color: #b45309; }
    .badge-ready { background: #dcfce7; color: #16a34a; }
    .badge-listing { background: #fef3c7; color: #b45309; }
    .badge-listed { background: #22c55e; color: #fff; }
    .badge-rejected { background: #fee2e2; color: #dc2626; }
    .badge-verifying { background: #f3e8ff; color: #7c3aed; }

    /* Claude button */
    .btn-claude { background: #7c3aed; color: #fff; }
    .btn-claude:hover { background: #6d28d9; }
    .btn-claude:disabled { background: #ddd6fe; color: #a78bfa; cursor: not-allowed; transform: none; }

    /* Actions cell */
    .cell-actions { display: flex; gap: 6px; align-items: center; white-space: nowrap; }

    /* eBay link in status */
    .ebay-link { color: #4f6ef7; text-decoration: none; font-size: 11px; }
    .ebay-link:hover { text-decoration: underline; }

    /* ══════════════════════════════════════
       Detail Modal
       ══════════════════════════════════════ */
    .modal-overlay {
      display: none; position: fixed; inset: 0; z-index: 1000;
      background: rgba(0,0,0,0.35); backdrop-filter: blur(6px);
      align-items: center; justify-content: center;
    }
    .modal-overlay.open { display: flex; }

    .modal {
      background: #fff; border: 1px solid #e5e7eb; border-radius: 16px;
      width: 90vw; max-width: 900px; max-height: 85vh;
      display: flex; flex-direction: column; overflow: hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,0.12);
    }

    .modal-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 16px 24px; border-bottom: 1px solid #e5e7eb;
    }
    .modal-header h3 {
      font-size: 15px; font-weight: 600; color: #1a1a2e;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
      flex: 1; margin-right: 16px;
    }
    .modal-close {
      width: 32px; height: 32px; border: none; border-radius: 8px;
      background: #f0f1f3; color: #8b8fa3; font-size: 18px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: all 0.15s; flex-shrink: 0;
    }
    .modal-close:hover { background: #e5e7eb; color: #1a1a2e; }

    .modal-body {
      padding: 20px 24px; overflow-y: auto; flex: 1;
    }

    /* Modal: Image strip */
    .modal-images {
      display: flex; gap: 8px; overflow-x: auto;
      padding-bottom: 8px; margin-bottom: 16px;
      align-items: center; flex-wrap: wrap;
    }
    .modal-images::-webkit-scrollbar { height: 5px; }
    .modal-images::-webkit-scrollbar-track { background: transparent; }
    .modal-images::-webkit-scrollbar-thumb { background: #d1d5db; border-radius: 3px; }
    .modal-thumb {
      width: 80px; height: 80px; border-radius: 10px; object-fit: cover;
      flex-shrink: 0; background: #f0f1f3; border: 2px solid transparent;
      cursor: pointer; transition: border-color 0.15s; position: relative;
    }
    .modal-thumb:hover { border-color: #4f6ef7; }
    .modal-thumb-wrap {
      position: relative; display: inline-block; flex-shrink: 0;
    }
    .modal-thumb-remove {
      position: absolute; top: -4px; right: -4px; width: 20px; height: 20px;
      background: #ef4444; border: 2px solid #fff; border-radius: 50%;
      color: #fff; font-size: 12px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      opacity: 0; transition: opacity 0.15s; line-height: 1;
    }
    .modal-thumb-wrap:hover .modal-thumb-remove { opacity: 1; }
    .modal-add-photo {
      width: 80px; height: 80px; border-radius: 10px;
      border: 2px dashed #cbd5e1; background: #f8f9fb;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer; transition: all 0.15s; flex-shrink: 0;
      font-size: 11px; color: #8b8fa3; gap: 2px;
    }
    .modal-add-photo:hover { border-color: #4f6ef7; background: #eef1ff; color: #4f6ef7; }
    .modal-add-photo .plus { font-size: 22px; line-height: 1; }

    /* Modal: Title block */
    .modal-title-block {
      background: #f8f9fb; border: 1px solid #e5e7eb; border-radius: 10px;
      padding: 12px 16px; margin-bottom: 14px;
    }
    .modal-title-label {
      font-size: 10px; font-weight: 600; text-transform: uppercase;
      letter-spacing: 0.5px; color: #8b8fa3; margin-bottom: 5px;
    }
    .modal-title-row {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
    }
    .modal-title-text {
      font-size: 14px; font-weight: 600; color: #1a1a2e; flex: 1;
      background: #fff; border: 1px solid #d1d5db; border-radius: 8px;
      padding: 7px 10px; outline: none; transition: border-color 0.15s;
      font-family: inherit;
    }
    .modal-title-text:focus { border-color: #4f6ef7; }
    .modal-title-charcount { font-size: 11px; color: #8b8fa3; white-space: nowrap; }

    .copy-btn {
      padding: 4px 12px; border: 1px solid #d1d5db; border-radius: 6px;
      background: #fff; color: #8b8fa3; font-size: 11px;
      cursor: pointer; transition: all 0.15s; white-space: nowrap;
    }
    .copy-btn:hover { border-color: #a0a5b8; color: #555b6e; }
    .copy-btn.copied { border-color: #22c55e; color: #16a34a; }

    /* Modal: Description tabs */
    .modal-desc-block {
      background: #f8f9fb; border: 1px solid #e5e7eb; border-radius: 10px;
      overflow: hidden; margin-bottom: 16px;
    }
    .modal-desc-tabs { display: flex; border-bottom: 1px solid #e5e7eb; }
    .modal-desc-tab {
      padding: 8px 16px; font-size: 12px; font-weight: 600;
      color: #8b8fa3; background: transparent; border: none;
      cursor: pointer; transition: all 0.15s;
    }
    .modal-desc-tab:hover { color: #555b6e; }
    .modal-desc-tab.active { color: #4f6ef7; background: #fff; }
    .modal-desc-preview {
      padding: 16px; max-height: 350px; overflow-y: auto;
      background: #fff; color: #000;
    }
    .modal-desc-code { padding: 16px; max-height: 300px; overflow: auto; display: none; }
    .modal-desc-code pre {
      font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 11px; color: #64748b; white-space: pre-wrap;
      word-break: break-all; line-height: 1.5;
    }
    .modal-desc-edit {
      display: none; padding: 0;
    }
    .modal-desc-edit textarea {
      width: 100%; min-height: 280px; padding: 16px; border: none;
      background: #fff; color: #334155; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
      font-size: 12px; line-height: 1.5; resize: vertical; outline: none;
    }

    /* Modal: Fields grid */
    .modal-fields {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px;
      margin-bottom: 16px;
    }
    .modal-field label {
      display: block; font-size: 11px; font-weight: 600;
      text-transform: uppercase; letter-spacing: 0.5px;
      color: #8b8fa3; margin-bottom: 4px;
    }
    .modal-field input,
    .modal-field select {
      width: 100%; padding: 7px 10px; border: 1px solid #d1d5db;
      border-radius: 8px; background: #fff; color: #1a1a2e;
      font-size: 13px; outline: none; transition: border-color 0.15s;
    }
    .modal-field input:focus,
    .modal-field select:focus { border-color: #4f6ef7; }
    .modal-field .aspect-combo {
      position: relative;
    }
    .modal-field .aspect-combo input {
      padding-right: 28px;
    }
    .modal-field .aspect-combo .aspect-arrow {
      position: absolute; right: 10px; top: 50%; transform: translateY(-50%);
      pointer-events: none; font-size: 10px; color: #8b8fa3;
    }
    .modal-field .aspect-combo .aspect-list {
      position: absolute; top: 100%; left: 0; right: 0; max-height: 180px;
      overflow-y: auto; background: #fff; border: 1px solid #d1d5db; border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); z-index: 100; display: none;
    }
    .modal-field .aspect-combo .aspect-list.open { display: block; }
    .modal-field .aspect-combo .aspect-option {
      padding: 6px 10px; font-size: 12px; cursor: pointer;
    }
    .modal-field .aspect-combo .aspect-option:hover { background: #f0f3ff; }
    .modal-field label .req { color: #ef4444; font-size: 10px; margin-left: 4px; }
    .aspects-section-title {
      font-size: 11px; font-weight: 700; color: #4f6ef7; text-transform: uppercase;
      letter-spacing: 0.5px; margin: 16px 0 8px; padding-bottom: 6px;
      border-bottom: 1px solid #eef1ff; grid-column: 1 / -1;
      display: flex; align-items: center; gap: 10px;
    }
    .aspects-autofill-btn {
      margin-left: auto; padding: 3px 10px; border: 1px solid #4f6ef7; border-radius: 6px;
      background: #eef1ff; color: #4f6ef7; font-size: 11px; font-weight: 600;
      cursor: pointer; transition: all 0.15s; text-transform: none; letter-spacing: 0;
    }
    .aspects-autofill-btn:hover { background: #4f6ef7; color: #fff; }
    .aspects-autofill-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .aspects-loading {
      grid-column: 1 / -1; font-size: 12px; color: #8b8fa3; padding: 8px 0;
    }

    /* Offers & Promotions section */
    .offers-section {
      grid-column: 1 / -1;
      margin-top: 8px;
    }
    .offers-section-title {
      font-size: 11px; font-weight: 700; color: #4f6ef7; text-transform: uppercase;
      letter-spacing: 0.5px; margin: 0 0 12px; padding-bottom: 6px;
      border-bottom: 1px solid #eef1ff;
    }
    .offers-grid {
      display: grid; grid-template-columns: 1fr 1fr; gap: 12px 20px;
    }
    .offer-toggle {
      display: flex; align-items: center; gap: 10px;
    }
    .offer-toggle label {
      font-size: 13px; font-weight: 500; color: #1a1a2e; cursor: pointer;
      display: flex; align-items: center; gap: 8px;
    }
    .offer-toggle input[type="checkbox"] {
      width: 16px; height: 16px; accent-color: #4f6ef7; cursor: pointer;
    }
    .offer-sub-fields {
      grid-column: 1 / -1;
      display: none; gap: 12px 20px;
      grid-template-columns: 1fr 1fr;
      margin-top: 4px;
      padding: 12px; background: #f8f9fb; border-radius: 10px; border: 1px solid #e5e7eb;
    }
    .offer-sub-fields.open { display: grid; }
    .offer-sub-fields .modal-field label {
      font-size: 11px; color: #8b8fa3;
    }
    .offer-hint {
      font-size: 11px; color: #8b8fa3; margin-top: 2px;
    }

    /* Modal: Footer actions */
    .modal-footer {
      padding: 14px 24px; border-top: 1px solid #e5e7eb;
      display: flex; align-items: center; gap: 10px;
    }
    .modal-footer .spacer { flex: 1; }
    .modal-status { font-size: 12px; color: #8b8fa3; }
    .modal-status a { color: #4f6ef7; text-decoration: none; }

    /* ══════════════════════════════════════
       Vision Toggle & Image Upload
       ══════════════════════════════════════ */
    .vision-toggle-row {
      display: flex; align-items: center; gap: 14px; margin-bottom: 20px;
      padding-bottom: 16px; border-bottom: 1px solid #e5e7eb;
    }
    .vision-toggle-row label {
      font-size: 13px; font-weight: 600; color: #1a1a2e; cursor: pointer;
      display: flex; align-items: center; gap: 10px;
    }
    .toggle-switch {
      position: relative; width: 44px; height: 24px; flex-shrink: 0;
    }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .toggle-slider {
      position: absolute; inset: 0; background: #d1d5db; border-radius: 24px;
      cursor: pointer; transition: background 0.2s;
    }
    .toggle-slider::before {
      content: ''; position: absolute; left: 3px; top: 3px;
      width: 18px; height: 18px; background: #fff; border-radius: 50%;
      transition: transform 0.2s;
    }
    .toggle-switch input:checked + .toggle-slider { background: #4f6ef7; }
    .toggle-switch input:checked + .toggle-slider::before { transform: translateX(20px); }
    .vision-badge {
      font-size: 10px; font-weight: 700; text-transform: uppercase;
      letter-spacing: 0.5px; padding: 3px 8px; border-radius: 6px;
      background: #eef1ff; color: #4f6ef7;
    }

    .vision-upload-area { display: none; margin-top: 16px; }
    .vision-upload-area.active { display: block; }
    .vision-dropzone {
      border: 2px dashed #cbd5e1; border-radius: 14px; padding: 40px 24px;
      text-align: center; cursor: pointer; transition: all 0.2s;
      background: #f8f9fb; margin-bottom: 16px;
    }
    .vision-dropzone:hover, .vision-dropzone.dragover {
      border-color: #4f6ef7; background: #eef1ff;
    }
    .vision-dropzone-icon { font-size: 36px; color: #8b8fa3; margin-bottom: 8px; }
    .vision-dropzone-text { font-size: 14px; font-weight: 600; color: #555b6e; margin-bottom: 4px; }
    .vision-dropzone-hint { font-size: 12px; color: #8b8fa3; }

    .vision-image-grid {
      display: flex; gap: 10px; flex-wrap: wrap; margin-bottom: 16px;
    }
    .vision-thumb-wrap {
      position: relative; display: inline-block;
    }
    .vision-thumb {
      width: 90px; height: 90px; border-radius: 10px; object-fit: cover;
      border: 2px solid #e5e7eb; background: #f0f1f3;
    }
    .vision-thumb-remove {
      position: absolute; top: -6px; right: -6px; width: 22px; height: 22px;
      background: #ef4444; border: 2px solid #fff; border-radius: 50%;
      color: #fff; font-size: 13px; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      opacity: 0; transition: opacity 0.15s; line-height: 1;
    }
    .vision-thumb-wrap:hover .vision-thumb-remove { opacity: 1; }

    .vision-actions {
      display: flex; gap: 12px; align-items: center; flex-wrap: wrap;
    }

    @media (max-width: 900px) {
      .container { padding: 16px; }
      .product-table thead { display: none; }
      .product-table tbody tr { display: flex; flex-wrap: wrap; padding: 12px; gap: 10px; border-bottom: 1px solid #e5e7eb; }
      .product-table tbody td { padding: 0; }
      .modal-fields { grid-template-columns: 1fr; }
      .input-form { flex-direction: column; }
    }
  </style>
</head>
<body>
  <header>
    <h1>ListIQ</h1>
    <span>Enter product info, generate listings, publish to eBay</span>
  </header>

  <div class="container">
    <!-- Product Input Form -->
    <div class="input-section">
      <h2>Add Product</h2>

      <!-- Vision Toggle -->
      <div class="vision-toggle-row">
        <label>
          <span class="toggle-switch">
            <input type="checkbox" id="visionToggle">
            <span class="toggle-slider"></span>
          </span>
          Switch to Google Vision AI
        </label>
        <span class="vision-badge" id="visionBadge" style="display:none;">Vision Mode</span>
      </div>

      <!-- Manual input (default) -->
      <div id="manualInputArea">
        <div class="input-form">
          <div class="input-field">
            <label>Brand <span style="color:#ef4444;">*</span></label>
            <input type="text" id="brandInput" placeholder="e.g. Cisco, Dell, Apple" autocomplete="off">
          </div>
          <div class="input-field">
            <label>Manufacturer Part Number (MPN) <span style="color:#ef4444;">*</span></label>
            <input type="text" id="mpnInput" placeholder="e.g. SG350-28P, A2338" autocomplete="off">
          </div>
          <button class="btn btn-primary" id="addProductBtn">Add Product</button>
        </div>
      </div>

      <!-- Vision image upload -->
      <div class="vision-upload-area" id="visionUploadArea">
        <div class="vision-dropzone" id="visionDropzone">
          <div class="vision-dropzone-icon">&#128247;</div>
          <div class="vision-dropzone-text">Drop product images here or click to browse</div>
          <div class="vision-dropzone-hint">Upload one or more images of the product. Google Vision AI will identify the brand and item.</div>
        </div>
        <input type="file" id="visionFileInput" accept="image/*" multiple style="display:none;">
        <div class="vision-image-grid" id="visionImageGrid"></div>
        <div class="vision-actions">
          <button class="btn btn-primary" id="visionFindBtn" disabled>Find Item</button>
          <button class="btn btn-secondary btn-sm" id="visionClearBtn" style="display:none;">Clear All</button>
          <span class="status-text" id="visionStatus"></span>
        </div>
      </div>

      <div class="status-text" id="statusText"></div>
    </div>

    <!-- Results -->
    <div class="results-section" id="resultsSection" style="display:none;">
      <div class="results-toolbar">
        <h2 id="resultsHeading">Products</h2>
        <div class="results-toolbar-actions">
          <button class="btn btn-green btn-sm" id="generateAllBtn" style="display:none;">Generate All</button>
          <button class="btn btn-primary btn-sm" id="listAllBtn" style="display:none;">Publish All</button>
        </div>
      </div>
      <table class="product-table" id="productTable">
        <thead>
          <tr>
            <th>Product</th>
            <th>Price</th>
            <th>SKU</th>
            <th>Condition</th>
            <th>Status</th>
            <th>Actions</th>
          </tr>
        </thead>
        <tbody id="productTableBody"></tbody>
      </table>
    </div>
  </div>

  <!-- Detail Modal -->
  <div class="modal-overlay" id="modalOverlay">
    <div class="modal" id="modal">
      <div class="modal-header">
        <h3 id="modalTitle">Product Details</h3>
        <button class="modal-close" id="modalClose">&times;</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer" id="modalFooter"></div>
    </div>
  </div>

  <script>
    const OPENAI_URL = '/api/openai/chat';
    const CLAUDE_URL = '/api/claude/chat';

    const brandInput = document.getElementById('brandInput');
    const mpnInput = document.getElementById('mpnInput');
    const addProductBtn = document.getElementById('addProductBtn');
    const statusText = document.getElementById('statusText');
    const resultsSection = document.getElementById('resultsSection');
    const resultsHeading = document.getElementById('resultsHeading');
    const generateAllBtn = document.getElementById('generateAllBtn');
    const listAllBtn = document.getElementById('listAllBtn');
    const productTableBody = document.getElementById('productTableBody');
    const modalOverlay = document.getElementById('modalOverlay');
    const modalTitle = document.getElementById('modalTitle');
    const modalBody = document.getElementById('modalBody');
    const modalFooter = document.getElementById('modalFooter');

    let products = [];
    let currentModalIndex = -1;

    // ═══════════════════════════════════════
    //  Vision Mode Toggle & Image Upload
    // ═══════════════════════════════════════
    const visionToggle = document.getElementById('visionToggle');
    const visionBadge = document.getElementById('visionBadge');
    const manualInputArea = document.getElementById('manualInputArea');
    const visionUploadArea = document.getElementById('visionUploadArea');
    const visionDropzone = document.getElementById('visionDropzone');
    const visionFileInput = document.getElementById('visionFileInput');
    const visionImageGrid = document.getElementById('visionImageGrid');
    const visionFindBtn = document.getElementById('visionFindBtn');
    const visionClearBtn = document.getElementById('visionClearBtn');
    const visionStatus = document.getElementById('visionStatus');

    let visionImages = []; // { file, dataUrl, base64 }

    visionToggle.addEventListener('change', () => {
      const on = visionToggle.checked;
      manualInputArea.style.display = on ? 'none' : 'block';
      visionUploadArea.classList.toggle('active', on);
      visionBadge.style.display = on ? 'inline-block' : 'none';
    });

    // Dropzone events
    visionDropzone.addEventListener('click', () => visionFileInput.click());
    visionDropzone.addEventListener('dragover', (e) => { e.preventDefault(); visionDropzone.classList.add('dragover'); });
    visionDropzone.addEventListener('dragleave', () => visionDropzone.classList.remove('dragover'));
    visionDropzone.addEventListener('drop', (e) => {
      e.preventDefault();
      visionDropzone.classList.remove('dragover');
      handleVisionFiles(e.dataTransfer.files);
    });
    visionFileInput.addEventListener('change', () => {
      handleVisionFiles(visionFileInput.files);
      visionFileInput.value = '';
    });

    function handleVisionFiles(files) {
      for (const file of files) {
        if (!file.type.startsWith('image/')) continue;
        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const base64 = dataUrl.split(',')[1];
          visionImages.push({ file, dataUrl, base64 });
          renderVisionThumbs();
        };
        reader.readAsDataURL(file);
      }
    }

    function renderVisionThumbs() {
      visionImageGrid.innerHTML = '';
      visionImages.forEach((img, idx) => {
        const wrap = document.createElement('div');
        wrap.className = 'vision-thumb-wrap';
        wrap.innerHTML = `
          <img class="vision-thumb" src="${img.dataUrl}" alt="">
          <button class="vision-thumb-remove" data-idx="${idx}">&times;</button>
        `;
        wrap.querySelector('.vision-thumb-remove').addEventListener('click', () => {
          visionImages.splice(idx, 1);
          renderVisionThumbs();
        });
        visionImageGrid.appendChild(wrap);
      });
      visionFindBtn.disabled = visionImages.length === 0;
      visionClearBtn.style.display = visionImages.length > 0 ? 'inline-flex' : 'none';
    }

    visionClearBtn.addEventListener('click', () => {
      visionImages = [];
      renderVisionThumbs();
      visionStatus.textContent = '';
    });

    // ── Claude Opus image identification fallback ──
    async function identifyWithClaude(item) {
      // Send up to 3 images to Claude for identification
      const imagesToSend = item.images.slice(0, 3);

      const contentBlocks = [];
      for (const img of imagesToSend) {
        const mimeType = img.file?.type || 'image/jpeg';
        contentBlocks.push({
          type: 'image',
          source: {
            type: 'base64',
            media_type: mimeType,
            data: img.base64,
          },
        });
      }

      const labelsHint = item.labels?.length > 0 ? `\nVision detected labels: ${item.labels.join(', ')}` : '';
      const entitiesHint = item.webEntities?.length > 0 ? `\nVision detected web entities: ${item.webEntities.join(', ')}` : '';

      contentBlocks.push({
        type: 'text',
        text: `Identify this product from the image(s). I need the exact product identification for an eBay listing.${labelsHint}${entitiesHint}

Respond with ONLY a JSON object in this exact format, no markdown, no code blocks, no explanation:
{"productName": "Full Product Name", "brand": "Brand Name", "mpn": "Model or Part Number"}

If you can identify the specific model/part number, include it. If you can only identify the brand and general product type, that's fine — leave mpn as empty string.`,
      });

      const resp = await fetch(CLAUDE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: [
            {
              role: 'user',
              content: contentBlocks,
            },
          ],
          temperature: 0.3,
          max_tokens: 500,
        }),
      });

      if (!resp.ok) {
        const err = await resp.json();
        throw new Error(err.error?.message || `Claude error ${resp.status}`);
      }

      const data = await resp.json();
      const raw = data.choices?.[0]?.message?.content || '';

      let jsonStr = raw.trim();
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
      }

      const result = JSON.parse(jsonStr);
      return {
        productName: result.productName || '',
        brand: result.brand || '',
        mpn: result.mpn || '',
      };
    }

    // ── Find Item with Google Vision ──
    visionFindBtn.addEventListener('click', analyzeWithVision);

    async function analyzeWithVision() {
      if (visionImages.length === 0) return;

      visionFindBtn.disabled = true;
      visionFindBtn.textContent = 'Analyzing...';
      visionStatus.innerHTML = '<span class="spinner"></span>Sending images to Google Vision AI...';

      try {
        const requests = visionImages.map(img => ({
          image: { content: img.base64 },
          features: [
            { type: 'LABEL_DETECTION', maxResults: 15 },
            { type: 'WEB_DETECTION', maxResults: 10 },
            { type: 'LOGO_DETECTION', maxResults: 5 },
            { type: 'OBJECT_LOCALIZATION', maxResults: 5 },
          ],
        }));

        const resp = await fetch('/api/vision/annotate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ requests }),
        });

        if (!resp.ok) {
          const err = await resp.json();
          throw new Error(err.error?.message || `Vision API error ${resp.status}`);
        }

        const data = await resp.json();
        if (data.error) throw new Error(data.error.message || 'Vision API error');

        visionStatus.innerHTML = '<span class="spinner"></span>Identifying products...';

        // Parse Vision responses
        const analyzed = data.responses.map((res, i) => ({
          index: i,
          img: visionImages[i],
          response: res,
          bestGuess: res.webDetection?.bestGuessLabels?.[0]?.label || '',
          labels: new Set((res.labelAnnotations || []).map(l => l.description.toLowerCase())),
          webEntities: new Set((res.webDetection?.webEntities || []).filter(e => e.description).map(e => e.description.toLowerCase())),
          logos: new Set((res.logoAnnotations || []).map(l => l.description.toLowerCase())),
          objects: new Set((res.localizedObjectAnnotations || []).map(o => o.name.toLowerCase())),
          webEntityScores: new Map((res.webDetection?.webEntities || []).filter(e => e.description).map(e => [e.description.toLowerCase(), e.score || 0])),
        }));

        // Log for debugging
        analyzed.forEach((a, i) => {
          console.log(`[Vision] Image ${i}:`, {
            bestGuess: a.bestGuess,
            labels: [...a.labels],
            webEntities: [...a.webEntities],
            logos: [...a.logos],
            objects: [...a.objects],
          });
        });

        // Cluster similar images using Union-Find
        const parent = analyzed.map((_, i) => i);
        function find(x) { return parent[x] === x ? x : (parent[x] = find(parent[x])); }
        function union(a, b) { parent[find(a)] = find(b); }

        function jaccard(setA, setB) {
          if (setA.size === 0 && setB.size === 0) return 0;
          let inter = 0;
          for (const v of setA) if (setB.has(v)) inter++;
          return inter / (setA.size + setB.size - inter);
        }

        for (let i = 0; i < analyzed.length; i++) {
          for (let j = i + 1; j < analyzed.length; j++) {
            const a = analyzed[i], b = analyzed[j];
            let sim = jaccard(a.labels, b.labels) * 0.3
                    + jaccard(a.webEntities, b.webEntities) * 0.3
                    + jaccard(a.objects, b.objects) * 0.1
                    + jaccard(a.logos, b.logos) * 0.1;
            if (a.bestGuess && b.bestGuess && a.bestGuess.toLowerCase() === b.bestGuess.toLowerCase()) sim += 0.05;
            const sharedLogos = [...a.logos].filter(l => b.logos.has(l));
            if (sharedLogos.length > 0) sim += 0.1;
            if (sim >= 0.3) union(i, j);
          }
        }

        // Group by cluster
        const clusters = {};
        analyzed.forEach((a, i) => {
          const root = find(i);
          if (!clusters[root]) clusters[root] = [];
          clusters[root].push(a);
        });

        // Generic labels to filter out
        const genericLabels = new Set([
          'product', 'electronics', 'technology', 'gadget', 'device', 'hardware',
          'font', 'logo', 'rectangle', 'text', 'brand', 'photo', 'image', 'picture',
          'material property', 'electric blue', 'automotive exterior',
        ]);

        // Name each cluster
        const identified = Object.values(clusters).map(group => {
          const allScores = new Map();
          const allLabels = new Set();
          const allLogos = new Set();
          const allObjects = new Set();
          let bestGuess = '';

          group.forEach(a => {
            a.webEntityScores.forEach((score, name) => {
              allScores.set(name, Math.max(allScores.get(name) || 0, score));
            });
            a.labels.forEach(l => allLabels.add(l));
            a.logos.forEach(l => allLogos.add(l));
            a.objects.forEach(o => allObjects.add(o));
            if (!bestGuess && a.bestGuess) bestGuess = a.bestGuess;
          });

          // Naming priority
          let productName = '';
          let brand = '';

          // 1. High-confidence web entity (score >= 0.7)
          const highConf = [...allScores.entries()]
            .filter(([name, score]) => score >= 0.7 && !genericLabels.has(name))
            .sort((a, b) => b[1] - a[1]);
          if (highConf.length > 0) {
            productName = highConf[0][0];
          }
          // 2. Best guess
          else if (bestGuess && !genericLabels.has(bestGuess.toLowerCase())) {
            productName = bestGuess;
          }
          // 3. Medium-confidence web entity (score >= 0.4)
          else {
            const medConf = [...allScores.entries()]
              .filter(([name, score]) => score >= 0.4 && !genericLabels.has(name))
              .sort((a, b) => b[1] - a[1]);
            if (medConf.length > 0) {
              productName = medConf[0][0];
            }
            // 4. Logo + top label
            else if (allLogos.size > 0) {
              const topLabel = [...allLabels].find(l => !genericLabels.has(l)) || '';
              productName = [...allLogos][0] + (topLabel ? ' ' + topLabel : '');
            }
            // 5. Top non-generic label
            else {
              const topLabel = [...allLabels].find(l => !genericLabels.has(l));
              productName = topLabel || [...allObjects][0] || 'Unknown product';
            }
          }

          // Extract brand from logos
          if (allLogos.size > 0) brand = [...allLogos][0];

          // Capitalize product name nicely
          productName = productName.replace(/\b\w/g, c => c.toUpperCase());
          brand = brand.replace(/\b\w/g, c => c.toUpperCase());

          return {
            productName,
            brand,
            images: group.map(a => a.img),
            labels: [...allLabels].slice(0, 10),
            webEntities: [...allScores.entries()].sort((a, b) => b[1] - a[1]).slice(0, 5).map(e => e[0]),
          };
        });

        console.log('[Vision] Identified products:', identified);

        // ── Claude Opus fallback for unknown/generic products ──
        const needsClaude = identified.filter(item =>
          !item.productName ||
          item.productName.toLowerCase() === 'unknown product' ||
          genericLabels.has(item.productName.toLowerCase())
        );

        if (needsClaude.length > 0) {
          visionStatus.innerHTML = '<span class="spinner"></span>Vision uncertain — asking Claude Opus to identify...';

          for (const item of needsClaude) {
            try {
              const result = await identifyWithClaude(item);
              if (result.productName) item.productName = result.productName;
              if (result.brand) item.brand = result.brand;
              if (result.mpn) item.mpn = result.mpn;
              item._claudeIdentified = true;
              console.log('[Claude Vision] Identified:', result);
            } catch (err) {
              console.error('[Claude Vision] Fallback error:', err);
            }
          }
        }

        // Add identified products to the product list
        for (const item of identified) {
          const product = {
            brand: item.brand || '',
            mpn: item.mpn || '',
            productName: item.productName,
            images: item.images,
            generatedTitle: null,
            generatedHtml: null,
            suggestedCategoryId: null,
            suggestedCategoryName: null,
            suggestedBrand: item.brand || '',
            suggestedType: null,
            suggestedMpn: item.mpn || '',
            ebayItemId: null,
            rejected: false,
            status: 'pending',
            _visionLabels: item.labels,
            _visionWebEntities: item.webEntities,
            _visionIdentified: true,
            _claudeIdentified: item._claudeIdentified || false,
          };
          products.push(product);
        }

        renderProductTable();

        const count = identified.length;
        visionStatus.textContent = `Found ${count} product${count !== 1 ? 's' : ''}. You can now generate listings.`;

        // Clear vision images for next batch
        visionImages = [];
        renderVisionThumbs();

      } catch (err) {
        visionStatus.textContent = `Error: ${err.message}`;
        console.error('[Vision] Error:', err);
      }

      visionFindBtn.disabled = visionImages.length === 0;
      visionFindBtn.textContent = 'Find Item';
    }

    // ═══════════════════════════════════════
    //  Add Product
    // ═══════════════════════════════════════
    addProductBtn.addEventListener('click', addProduct);
    mpnInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addProduct(); });
    brandInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') mpnInput.focus(); });

    function addProduct() {
      const brand = brandInput.value.trim();
      const mpn = mpnInput.value.trim();

      if (!brand) { brandInput.focus(); return alert('Please enter a Brand.'); }
      if (!mpn) { mpnInput.focus(); return alert('Please enter a Manufacturer Part Number (MPN).'); }

      const product = {
        brand,
        mpn,
        productName: `${brand} ${mpn}`,
        images: [],          // { file, dataUrl, base64 }
        generatedTitle: null,
        generatedHtml: null,
        suggestedCategoryId: null,
        suggestedCategoryName: null,
        suggestedBrand: brand,
        suggestedType: null,
        suggestedMpn: mpn,
        ebayItemId: null,
        rejected: false,
        status: 'pending',
      };

      products.push(product);
      brandInput.value = '';
      mpnInput.value = '';
      brandInput.focus();

      renderProductTable();
      statusText.textContent = `Added: ${brand} ${mpn}`;
    }

    // ═══════════════════════════════════════
    //  Render product table
    // ═══════════════════════════════════════
    function renderProductTable() {
      productTableBody.innerHTML = '';
      resultsSection.style.display = products.length > 0 ? 'block' : 'none';
      generateAllBtn.style.display = products.length > 0 ? 'inline-flex' : 'none';
      listAllBtn.style.display = products.length > 0 ? 'inline-flex' : 'none';
      resultsHeading.textContent = `${products.length} Product${products.length !== 1 ? 's' : ''}`;

      products.forEach((meta, ci) => {
        const tr = document.createElement('tr');
        tr.id = `row-${ci}`;
        tr.innerHTML = buildRowHtml(ci, meta);
        productTableBody.appendChild(tr);
        attachRowEvents(ci);
      });
    }

    function buildRowHtml(ci, meta) {
      const title = meta.generatedTitle || meta.productName;
      let metaLine = '';
      if (meta._visionIdentified) {
        metaLine = `<span style="color:#4f6ef7;font-weight:600;">Vision AI</span>`;
        if (meta._claudeIdentified) metaLine += `<span style="color:#7c3aed;font-weight:600;">+ Claude</span>`;
        if (meta.brand) metaLine += `<span>Brand: ${escapeHtml(meta.brand)}</span>`;
        if (meta.mpn) metaLine += `<span>MPN: ${escapeHtml(meta.mpn)}</span>`;
      } else {
        metaLine = `<span>Brand: ${escapeHtml(meta.brand)}</span><span>MPN: ${escapeHtml(meta.mpn)}</span>`;
      }
      if (meta.suggestedCategoryName) metaLine += `<span>Cat: ${escapeHtml(meta.suggestedCategoryName)}</span>`;
      if (meta.images.length > 0) metaLine += `<span>${meta.images.length} photo${meta.images.length !== 1 ? 's' : ''}</span>`;

      const statusHtml = buildStatusBadge(meta);
      const actionsHtml = buildActions(ci, meta);

      return `
        <td>
          <div class="cell-product-title">${escapeHtml(title)}</div>
          <div class="cell-product-meta">${metaLine}</div>
        </td>
        <td>
          <div class="price-cell-wrap">
            <input type="number" class="cell-price-input" id="price-${ci}" placeholder="0.00" min="0.01" step="0.01" ${meta.status === 'listed' || meta.status === 'rejected' ? 'disabled' : ''}>
            ${meta.status !== 'listed' && meta.status !== 'rejected' ? `<button class="price-range-btn" id="priceRangeBtn-${ci}">Lookup Price</button>` : ''}
            <div id="priceRange-${ci}"></div>
          </div>
        </td>
        <td><input type="text" class="cell-price-input" id="sku-${ci}" placeholder="SKU" maxlength="50" ${meta.status === 'listed' || meta.status === 'rejected' ? 'disabled' : ''}></td>
        <td>
          <select class="cell-cond-select" id="condition-${ci}" ${meta.status === 'listed' || meta.status === 'rejected' ? 'disabled' : ''}>
            <option value="1000">New</option>
            <option value="1500">New other</option>
            <option value="1750">New w/ defects</option>
            <option value="2500">Refurbished</option>
            <option value="3000" selected>Used</option>
            <option value="5000">Good</option>
            <option value="7000">For parts</option>
          </select>
        </td>
        <td id="status-${ci}">${statusHtml}</td>
        <td><div class="cell-actions" id="actions-${ci}">${actionsHtml}</div></td>
      `;
    }

    function buildStatusBadge(meta) {
      const s = meta.status;
      if (s === 'pending') return '<span class="badge badge-pending">Pending</span>';
      if (s === 'generating') return '<span class="badge badge-generating"><span class="spinner spinner-sm" style="border-top-color:#b45309;"></span>Generating</span>';
      if (s === 'ready') return '<span class="badge badge-ready">Ready</span>';
      if (s === 'verifying') return '<span class="badge badge-verifying"><span class="spinner spinner-sm" style="border-top-color:#7c3aed;"></span>Verifying</span>';
      if (s === 'listing') return '<span class="badge badge-listing"><span class="spinner spinner-sm" style="border-top-color:#b45309;"></span>Listing</span>';
      if (s === 'listed') {
        let html = '<span class="badge badge-listed">Listed</span>';
        if (meta.ebayItemId) html += `<br><a class="ebay-link" href="https://www.ebay.com/itm/${meta.ebayItemId}" target="_blank">#${meta.ebayItemId}</a>`;
        return html;
      }
      if (s === 'rejected') return '<span class="badge badge-rejected">Rejected</span>';
      return '';
    }

    function buildActions(ci, meta) {
      const s = meta.status;
      if (s === 'pending') {
        return `<button class="btn btn-green btn-xs" id="genBtn-${ci}">Generate with OpenAI</button>
                <button class="btn btn-red btn-xs" id="removeBtn-${ci}">Remove</button>`;
      }
      if (s === 'generating') {
        return `<button class="btn btn-green btn-xs" disabled>Generating...</button>`;
      }
      if (s === 'ready') {
        return `
          <button class="btn btn-xs" style="background:#f59e0b;color:#fff;" id="detailBtn-${ci}">Preview</button>
          <button class="btn btn-claude btn-xs" id="verifyBtn-${ci}"${meta._claudeVerified ? ' title="Already verified"' : ''}>Verify with Claude</button>
          <button class="btn btn-green btn-xs" id="listBtn-${ci}">Publish</button>
          <button class="btn btn-red btn-xs" id="rejectBtn-${ci}">Reject</button>
        `;
      }
      if (s === 'verifying') {
        return `<button class="btn btn-claude btn-xs" disabled>Verifying...</button>`;
      }
      if (s === 'listing') {
        return `<button class="btn btn-green btn-xs" disabled>Listing...</button>`;
      }
      if (s === 'listed') {
        return `<button class="btn btn-xs" style="background:#e9ecef;color:#555b6e;" id="detailBtn-${ci}">Details</button>`;
      }
      if (s === 'rejected') {
        return `<span style="font-size:11px;color:#8b8fa3;">Rejected</span>`;
      }
      return '';
    }

    function updateRow(ci) {
      const meta = products[ci];
      const tr = document.getElementById(`row-${ci}`);
      if (!tr) return;

      const priceEl = document.getElementById(`price-${ci}`);
      const condEl = document.getElementById(`condition-${ci}`);
      const skuEl = document.getElementById(`sku-${ci}`);
      const savedPrice = priceEl ? priceEl.value : '';
      const savedCond = condEl ? condEl.value : '3000';
      const savedSku = skuEl ? skuEl.value : (meta._sku || '');

      tr.innerHTML = buildRowHtml(ci, meta);
      tr.className = meta.status === 'rejected' ? 'row-rejected' : meta.status === 'listed' ? 'row-listed' : '';

      const newPrice = document.getElementById(`price-${ci}`);
      const newCond = document.getElementById(`condition-${ci}`);
      const newSku = document.getElementById(`sku-${ci}`);
      if (newPrice && savedPrice) newPrice.value = savedPrice;
      if (newCond && savedCond) newCond.value = savedCond;
      if (newSku && savedSku) newSku.value = savedSku;

      if (meta._priceRange) {
        const pr = meta._priceRange;
        const prContainer = document.getElementById(`priceRange-${ci}`);
        if (prContainer) {
          prContainer.innerHTML = `
            <div class="price-range-info">
              <span class="pr-label">Market (${pr.count} listings):</span><br>
              <span class="pr-val">$${pr.low} – $${pr.high}</span><br>
              <span class="pr-label">Avg:</span> <span class="pr-val">$${pr.avg}</span>
              <span class="pr-label">Med:</span> <span class="pr-val">$${pr.median}</span>
            </div>
          `;
        }
      }

      attachRowEvents(ci);
    }

    function attachRowEvents(ci) {
      const genBtn = document.getElementById(`genBtn-${ci}`);
      if (genBtn) genBtn.addEventListener('click', () => generateListing(ci));

      const listBtn = document.getElementById(`listBtn-${ci}`);
      if (listBtn) listBtn.addEventListener('click', () => listOnEbay(ci));

      const detailBtn = document.getElementById(`detailBtn-${ci}`);
      if (detailBtn) detailBtn.addEventListener('click', () => openModal(ci));

      const rejectBtn = document.getElementById(`rejectBtn-${ci}`);
      if (rejectBtn) rejectBtn.addEventListener('click', () => rejectListing(ci));

      const verifyBtn = document.getElementById(`verifyBtn-${ci}`);
      if (verifyBtn) verifyBtn.addEventListener('click', () => verifyWithClaude(ci));

      const removeBtn = document.getElementById(`removeBtn-${ci}`);
      if (removeBtn) removeBtn.addEventListener('click', () => {
        products.splice(ci, 1);
        renderProductTable();
      });

      const prBtn = document.getElementById(`priceRangeBtn-${ci}`);
      if (prBtn) prBtn.addEventListener('click', () => lookupPriceRange(ci));
    }

    // ── Price range lookup ──
    async function lookupPriceRange(ci) {
      const meta = products[ci];
      const btn = document.getElementById(`priceRangeBtn-${ci}`);
      const container = document.getElementById(`priceRange-${ci}`);
      if (!container) return;

      const query = meta.generatedTitle || meta.productName || '';
      if (!query) { alert('No product name to search for.'); return; }

      btn.textContent = 'Looking up...';
      btn.disabled = true;

      try {
        const params = new URLSearchParams({ q: query });
        if (meta.suggestedCategoryId) params.set('category_id', meta.suggestedCategoryId);

        const resp = await fetch(`/api/ebay/price-range?${params}`);
        const data = await resp.json();

        if (!data.success) throw new Error(data.error);
        if (data.count === 0) {
          container.innerHTML = '<div class="price-range-info"><span class="pr-label">No listings found</span></div>';
        } else {
          container.innerHTML = `
            <div class="price-range-info">
              <span class="pr-label">Market (${data.count} listings):</span><br>
              <span class="pr-val">$${data.low} – $${data.high}</span><br>
              <span class="pr-label">Avg:</span> <span class="pr-val">$${data.avg}</span>
              <span class="pr-label">Med:</span> <span class="pr-val">$${data.median}</span>
            </div>
          `;
          meta._priceRange = data;
        }
      } catch (err) {
        container.innerHTML = `<div class="price-range-info" style="color:#ef4444;">${err.message}</div>`;
      }
      btn.textContent = 'Lookup Price';
      btn.disabled = false;
    }

    // ═══════════════════════════════════════
    //  Generate All + List All
    // ═══════════════════════════════════════
    generateAllBtn.addEventListener('click', async () => {
      generateAllBtn.disabled = true;
      generateAllBtn.textContent = 'Generating...';
      for (let i = 0; i < products.length; i++) {
        if (!products[i].generatedHtml && !products[i].rejected) await generateListing(i);
      }
      generateAllBtn.disabled = false;
      generateAllBtn.textContent = 'Generate All';
    });

    listAllBtn.addEventListener('click', async () => {
      listAllBtn.disabled = true;
      listAllBtn.textContent = 'Publishing...';
      for (let i = 0; i < products.length; i++) {
        const m = products[i];
        if (m.status === 'ready' && !m.rejected && !m.ebayItemId) {
          const priceEl = document.getElementById(`price-${i}`);
          if (priceEl && parseFloat(priceEl.value) > 0) {
            await listOnEbay(i);
          }
        }
      }
      listAllBtn.disabled = false;
      listAllBtn.textContent = 'Publish All';
    });

    // ═══════════════════════════════════════
    //  OpenAI listing generation
    // ═══════════════════════════════════════
    async function generateListing(ci) {
      const meta = products[ci];
      meta.status = 'generating';
      updateRow(ci);

      const prompt = meta._visionIdentified
        ? buildVisionPrompt(meta)
        : buildPrompt(meta.brand, meta.mpn);

      try {
        const resp = await fetch(OPENAI_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: [
              { role: 'system', content: 'You are an expert eBay listing copywriter. You output only the requested content, no commentary.' },
              { role: 'user', content: prompt }
            ],
            temperature: 0.7,
            max_completion_tokens: 4000
          })
        });
        if (!resp.ok) { const err = await resp.json(); throw new Error(err.error?.message || `OpenAI error ${resp.status}`); }
        const data = await resp.json();
        const raw = data.choices[0].message.content.trim();
        const { title, html, categoryId, categoryName, brand, type, mpn } = parseListingResponse(raw, meta.productName);
        meta.generatedTitle = title;
        meta.generatedHtml = html;
        meta.suggestedBrand = brand || meta.brand;
        meta.suggestedType = type;
        meta.suggestedMpn = mpn || meta.mpn;
        // For Vision-identified products, update brand/mpn from AI response
        if (meta._visionIdentified) {
          if (brand && !meta.brand) meta.brand = brand;
          if (mpn && !meta.mpn) meta.mpn = mpn;
        }

        // Get verified leaf category from eBay Taxonomy API
        meta._listingProgress = 'Finding best category...';
        updateRow(ci);

        try {
          const catResp = await fetch(`/api/ebay/category-suggestions?q=${encodeURIComponent(title || meta.productName)}`);
          const catData = await catResp.json();
          if (catData.success && catData.suggestions?.length > 0) {
            meta.suggestedCategoryId = catData.suggestions[0].id;
            meta.suggestedCategoryName = catData.suggestions[0].name;
          } else {
            meta.suggestedCategoryId = categoryId;
            meta.suggestedCategoryName = categoryName;
          }
        } catch (e) {
          meta.suggestedCategoryId = categoryId;
          meta.suggestedCategoryName = categoryName;
        }

        // Fetch item aspects and auto-fill with AI
        if (meta.suggestedCategoryId) {
          meta._listingProgress = 'Filling item specifics...';
          updateRow(ci);
          try {
            await prefillItemAspects(meta);
          } catch (e) {
            console.error('Aspect prefill error:', e);
          }
        }

        meta.status = 'ready';
      } catch (err) {
        meta.status = 'pending';
        alert(`Generation error for "${meta.productName}": ${err.message}`);
      }
      updateRow(ci);
    }

    // ═══════════════════════════════════════
    //  Claude verification (second AI layer)
    // ═══════════════════════════════════════
    async function verifyWithClaude(ci) {
      const meta = products[ci];
      meta.status = 'verifying';
      updateRow(ci);

      const productLine = meta._visionIdentified
        ? `Product: ${meta.productName}${meta.brand ? ' | Brand: ' + meta.brand : ''}${meta.mpn ? ' | MPN: ' + meta.mpn : ''}${meta._visionLabels ? ' | Vision Labels: ' + meta._visionLabels.join(', ') : ''}`
        : `Brand: ${meta.brand} | MPN: ${meta.mpn}`;

      const verifyPrompt = `You are a senior eBay listing quality reviewer and SEO specialist. You have been given an existing eBay listing that was generated by another AI. Your job is to VERIFY and ENRICH it — not rewrite it from scratch.

PRODUCT: ${productLine}
CATEGORY: ${meta.suggestedCategoryName || 'Unknown'} (ID: ${meta.suggestedCategoryId || 'Unknown'})

EXISTING TITLE:
${meta.generatedTitle}

EXISTING HTML DESCRIPTION:
${meta.generatedHtml}

YOUR TASKS:
1. TITLE: Review the title. Fix any factual errors about the product. Improve keyword optimization for eBay Cassini search if possible. Keep it under 80 characters. If the title is already good, keep it as-is or make minor improvements only.
2. DESCRIPTION: Review the HTML description. Fix any factual inaccuracies about this specific product (specs, features, compatibility). Add any missing important details or keywords. Improve readability and buyer appeal if needed. Keep the same HTML structure and styling — do not change the layout, colors, or CSS. Only modify the text content where it genuinely needs improvement.
3. If something is already accurate and well-written, KEEP IT. Do not change things just to change them.

IMPORTANT: Your response MUST follow this exact format:
TITLE: [The verified/enriched title, max 80 chars]
CATEGORY_ID: ${meta.suggestedCategoryId || ''}
CATEGORY_NAME: ${meta.suggestedCategoryName || ''}
BRAND: ${meta.suggestedBrand || meta.brand}
TYPE: ${meta.suggestedType || ''}
MPN: ${meta.suggestedMpn || meta.mpn}
HTML:
[The verified/enriched HTML description]`;

      try {
        meta._listingProgress = 'Claude is verifying listing...';
        updateRow(ci);

        const resp = await fetch(CLAUDE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: [
              { role: 'system', content: 'You are a senior eBay listing quality reviewer. You verify and enrich existing listings — you do not rewrite them from scratch. Only change what genuinely needs improvement. Output only the requested content, no commentary.' },
              { role: 'user', content: verifyPrompt }
            ],
            temperature: 0.4,
            max_tokens: 4096
          })
        });
        if (!resp.ok) { const err = await resp.json(); throw new Error(err.error?.message || `Claude error ${resp.status}`); }
        const data = await resp.json();
        const raw = data.choices[0].message.content.trim();
        const { title, html, brand, type, mpn } = parseListingResponse(raw, meta.productName);
        meta.generatedTitle = title;
        meta.generatedHtml = html;
        if (brand) meta.suggestedBrand = brand;
        if (type) meta.suggestedType = type;
        if (mpn) meta.suggestedMpn = mpn;

        // Verify item aspects with Claude
        if (meta.suggestedCategoryId) {
          meta._listingProgress = 'Claude is verifying item specifics...';
          updateRow(ci);
          try {
            await verifyAspectsWithClaude(meta);
          } catch (e) {
            console.error('Claude aspect verification error:', e);
          }
        }

        meta._claudeVerified = true;
        meta.status = 'ready';
      } catch (err) {
        meta.status = 'ready';
        alert(`Claude verification error for "${meta.productName}": ${err.message}`);
      }
      updateRow(ci);
    }

    async function verifyAspectsWithClaude(meta) {
      const aspectResp = await fetch(`/api/ebay/item-aspects?category_id=${encodeURIComponent(meta.suggestedCategoryId)}`);
      const aspectData = await aspectResp.json();
      if (!aspectData.success || !aspectData.aspects?.length) return;

      const aspects = aspectData.aspects.sort((a, b) => {
        if (a.required !== b.required) return a.required ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
      const requiredAspects = aspects.filter(a => a.required);
      const recommendedAspects = aspects.filter(a => !a.required).slice(0, Math.max(0, 20 - requiredAspects.length));
      const shownAspects = [...requiredAspects, ...recommendedAspects];

      const productInfo = [
        meta.generatedTitle || meta.productName || '',
        `Brand: ${meta.brand}`,
        `MPN: ${meta.mpn}`,
      ].filter(Boolean).join(' | ');

      const existing = meta._itemAspects || {};
      if (!existing['Brand'] && meta.brand) existing['Brand'] = meta.suggestedBrand || meta.brand;
      if (!existing['Type'] && meta.suggestedType) existing['Type'] = meta.suggestedType;
      if (!existing['MPN'] && meta.mpn) existing['MPN'] = meta.suggestedMpn || meta.mpn;

      const fieldsToFill = shownAspects.map(asp => ({
        name: asp.name,
        required: asp.required,
        currentValue: existing[asp.name] || '',
        allowedValues: asp.values && asp.values.length > 0 ? asp.values : null,
      }));

      const prompt = `You are verifying and correcting eBay item specifics that were already filled by another AI. Your job is to CHECK each value for accuracy and CORRECT any mistakes.

Product: ${productInfo}

VERIFICATION RULES:
1. Each field has a "currentValue" — this was filled by another AI. KEEP IT if it looks correct for this product.
2. Only CHANGE a value if it is clearly WRONG or a better match exists.
3. If a field has "allowedValues", the value MUST be EXACTLY one from that list — copy it character-for-character.
4. If a field has no allowedValues (null), verify the text value is factually accurate for this specific product.
5. For required fields, ALWAYS provide a value. Use "Does Not Apply" only as a last resort.
6. Research this specific product (Brand: ${meta.brand}, MPN: ${meta.mpn}) to verify specs are correct.

Fields to verify:
${JSON.stringify(fieldsToFill, null, 2)}

Respond with ONLY a valid JSON object mapping field names to values (corrected or kept). No explanation, no markdown, no code blocks. Just the JSON object.`;

      const resp = await fetch(CLAUDE_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.3,
          max_tokens: 2000,
        }),
      });
      const data = await resp.json();
      const content = data.choices?.[0]?.message?.content || '';

      let jsonStr = content.trim();
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
      }
      const values = JSON.parse(jsonStr);

      const result = {};
      for (const asp of shownAspects) {
        let val = values[asp.name] ? String(values[asp.name]) : (existing[asp.name] || '');
        if (!val) continue;

        if (asp.values && asp.values.length > 0) {
          const exact = asp.values.find(v => v.toLowerCase() === val.toLowerCase());
          if (exact) {
            val = exact;
          } else {
            const partial = asp.values.find(v =>
              v.toLowerCase().includes(val.toLowerCase()) ||
              val.toLowerCase().includes(v.toLowerCase())
            );
            val = partial || asp.values[0];
          }
        }
        result[asp.name] = val;
      }

      meta._itemAspects = result;
      meta.suggestedBrand = result['Brand'] || meta.suggestedBrand || meta.brand || '';
      meta.suggestedType = result['Type'] || meta.suggestedType || '';
      meta.suggestedMpn = result['MPN'] || meta.suggestedMpn || meta.mpn || '';
    }

    function buildPrompt(brand, mpn) {
      const exampleHtml = `<div style="max-width:900px;margin:0 auto;font-family:Arial,Helvetica,sans-serif;color:#222;"><div style="background:#003366;padding:20px 30px;text-align:center;border-radius:8px 8px 0 0;"><h1 style="color:#ffffff;font-size:22px;margin:0;">Cisco SG350-28P 28-Port Gigabit PoE Managed Switch</h1></div><div style="padding:25px 30px;background:#f9f9f9;"><p style="font-size:15px;line-height:1.6;color:#333;">The <strong>Cisco SG350-28P</strong> is a high-performance <strong>28-port Gigabit PoE managed network switch</strong> designed for small to medium businesses.</p><h2 style="color:#003366;font-size:17px;border-bottom:2px solid #003366;padding-bottom:6px;">Key Features</h2><ul style="font-size:14px;line-height:1.8;color:#444;"><li><strong>28 Gigabit Ethernet Ports</strong> — 24x PoE+ ports, 2x combo mini-GBIC, 2x SFP</li><li><strong>195W PoE Budget</strong> — Power IP cameras, phones, access points</li><li><strong>Advanced L3 Managed</strong> — Static routing, ACLs, VLAN, QoS</li></ul><h2 style="color:#003366;font-size:17px;border-bottom:2px solid #003366;padding-bottom:6px;">Ideal For</h2><ul style="font-size:14px;line-height:1.8;color:#444;"><li>Small &amp; medium business networks</li><li>VoIP &amp; IP surveillance</li></ul></div><div style="background:#003366;padding:15px 30px;text-align:center;border-radius:0 0 8px 8px;"><p style="color:#ffffff;font-size:13px;margin:0;">Fast Shipping &bull; Professional Packaging &bull; Trusted Seller</p></div></div>`;

      return `Create a Cassini-optimized eBay product description (score 10/10) for the specified item. Use the same HTML color structure and styling as the example provided below.

Follow these detailed instructions:
- Use the existing format: header title block, centered image area, feature bullet list, and closing highlights.
- Do not mention any warranty (express or implied).
- Use flawless English, clear formatting, and no grammatical errors.
- Add relevant high-ranking eBay keywords (research and include extra keyword variations and synonyms naturally within the text).
- Emphasize features, compatibility, and typical use cases.
- Target both enterprise and individual buyers if applicable.
- Output should be ready for eBay, HTML included, without placeholder text.
- Make sure the listing description is 100% unique, well-written, and optimized for visibility and relevance in eBay Cassini search.
- Never change footer.
- Description must be copy-paste ready for eBay.
- Avoid extra \\n in the code.
- Research the product based on Brand and MPN to write an accurate and detailed description.

Here is an example of a well-structured listing:
${exampleHtml}

Now create the same thing for this item:
Brand: ${brand}
MPN (Manufacturer Part Number): ${mpn}

IMPORTANT: Your response MUST follow this exact format:
TITLE: [An eBay-optimized title, max 80 characters, keyword-rich, must include brand and MPN]
CATEGORY_ID: [The most appropriate eBay leaf category ID number, e.g. 31388 for Digital Cameras, 175673 for Network Switches, 171485 for Laptops. Use a real eBay category ID.]
CATEGORY_NAME: [The eBay category name for that ID]
BRAND: [${brand}]
TYPE: [The specific product type as used in eBay item specifics for this category, e.g. "Managed Switch", "Laptop", "Router". Be specific.]
MPN: [${mpn}]
HTML:
[The full HTML description code]`;
    }

    function buildVisionPrompt(meta) {
      const exampleHtml = `<div style="max-width:900px;margin:0 auto;font-family:Arial,Helvetica,sans-serif;color:#222;"><div style="background:#003366;padding:20px 30px;text-align:center;border-radius:8px 8px 0 0;"><h1 style="color:#ffffff;font-size:22px;margin:0;">Cisco SG350-28P 28-Port Gigabit PoE Managed Switch</h1></div><div style="padding:25px 30px;background:#f9f9f9;"><p style="font-size:15px;line-height:1.6;color:#333;">The <strong>Cisco SG350-28P</strong> is a high-performance <strong>28-port Gigabit PoE managed network switch</strong> designed for small to medium businesses.</p><h2 style="color:#003366;font-size:17px;border-bottom:2px solid #003366;padding-bottom:6px;">Key Features</h2><ul style="font-size:14px;line-height:1.8;color:#444;"><li><strong>28 Gigabit Ethernet Ports</strong> — 24x PoE+ ports, 2x combo mini-GBIC, 2x SFP</li><li><strong>195W PoE Budget</strong> — Power IP cameras, phones, access points</li><li><strong>Advanced L3 Managed</strong> — Static routing, ACLs, VLAN, QoS</li></ul><h2 style="color:#003366;font-size:17px;border-bottom:2px solid #003366;padding-bottom:6px;">Ideal For</h2><ul style="font-size:14px;line-height:1.8;color:#444;"><li>Small &amp; medium business networks</li><li>VoIP &amp; IP surveillance</li></ul></div><div style="background:#003366;padding:15px 30px;text-align:center;border-radius:0 0 8px 8px;"><p style="color:#ffffff;font-size:13px;margin:0;">Fast Shipping &bull; Professional Packaging &bull; Trusted Seller</p></div></div>`;

      const labelsStr = (meta._visionLabels || []).join(', ');
      const entitiesStr = (meta._visionWebEntities || []).join(', ');

      return `Create a Cassini-optimized eBay product description (score 10/10) for the specified item. Use the same HTML color structure and styling as the example provided below.

A product has been identified from images using Google Vision AI. Use the detected information to research the EXACT product and create an accurate listing.

DETECTED INFORMATION:
- Product Name: ${meta.productName}
${meta.brand ? `- Detected Brand: ${meta.brand}` : ''}
- Vision Labels: ${labelsStr || 'N/A'}
- Web Entities: ${entitiesStr || 'N/A'}

IMPORTANT: Based on the detected information above, research this specific product to find:
1. The exact Brand name
2. The exact Manufacturer Part Number (MPN) or model number
3. Accurate specifications and features

Follow these detailed instructions:
- Use the existing format: header title block, centered image area, feature bullet list, and closing highlights.
- Do not mention any warranty (express or implied).
- Use flawless English, clear formatting, and no grammatical errors.
- Add relevant high-ranking eBay keywords (research and include extra keyword variations and synonyms naturally within the text).
- Emphasize features, compatibility, and typical use cases.
- Target both enterprise and individual buyers if applicable.
- Output should be ready for eBay, HTML included, without placeholder text.
- Make sure the listing description is 100% unique, well-written, and optimized for visibility and relevance in eBay Cassini search.
- Never change footer.
- Description must be copy-paste ready for eBay.
- Avoid extra \\n in the code.

Here is an example of a well-structured listing:
${exampleHtml}

IMPORTANT: Your response MUST follow this exact format:
TITLE: [An eBay-optimized title, max 80 characters, keyword-rich, must include brand and model/MPN]
CATEGORY_ID: [The most appropriate eBay leaf category ID number. Use a real eBay category ID.]
CATEGORY_NAME: [The eBay category name for that ID]
BRAND: [The exact brand name of the product]
TYPE: [The specific product type as used in eBay item specifics, e.g. "Managed Switch", "Laptop", "Router". Be specific.]
MPN: [The exact Manufacturer Part Number or model number]
HTML:
[The full HTML description code]`;
    }

    function parseListingResponse(raw, fallback) {
      let title = fallback, html = raw, categoryId = '', categoryName = '';
      let brand = '', type = '', mpn = '';
      const tm = raw.match(/^TITLE:\s*(.+)/m);
      if (tm) title = tm[1].trim();
      const cm = raw.match(/^CATEGORY_ID:\s*(.+)/m);
      if (cm) categoryId = cm[1].trim();
      const cn = raw.match(/^CATEGORY_NAME:\s*(.+)/m);
      if (cn) categoryName = cn[1].trim();
      const bm = raw.match(/^BRAND:\s*(.+)/m);
      if (bm) brand = bm[1].trim();
      const tp = raw.match(/^TYPE:\s*(.+)/m);
      if (tp) type = tp[1].trim();
      const mp = raw.match(/^MPN:\s*(.+)/m);
      if (mp) mpn = mp[1].trim();
      const hm = raw.match(/HTML:\s*\n?([\s\S]+)/);
      if (hm) html = hm[1].trim();
      html = html.replace(/^```html?\s*\n?/i, '').replace(/\n?```\s*$/i, '').trim();
      return { title, html, categoryId, categoryName, brand, type, mpn };
    }

    // ═══════════════════════════════════════
    //  Modal
    // ═══════════════════════════════════════
    document.getElementById('modalClose').addEventListener('click', closeModal);
    modalOverlay.addEventListener('click', (e) => { if (e.target === modalOverlay) closeModal(); });
    document.addEventListener('keydown', (e) => { if (e.key === 'Escape') closeModal(); });

    function closeModal() {
      modalOverlay.classList.remove('open');
      currentModalIndex = -1;
    }

    async function openModal(ci) {
      const meta = products[ci];
      currentModalIndex = ci;
      modalTitle.textContent = meta.generatedTitle || meta.productName;

      const policies = await ensurePolicies();
      const shipOptions = (policies.shipping || []).map(s =>
        `<option value="${s.id}"${s.default ? ' selected' : ''}>${escapeHtml(s.name)}</option>`
      ).join('');
      const retOptions = (policies.returnPolicies || []).map(r =>
        `<option value="${r.id}"${r.default ? ' selected' : ''}>${escapeHtml(r.name)}</option>`
      ).join('');

      // Images section with add button
      let imagesHtml = '';
      meta.images.forEach((img, idx) => {
        imagesHtml += `
          <div class="modal-thumb-wrap" data-img-idx="${idx}">
            <img class="modal-thumb" src="${img.dataUrl}" alt="">
            <button class="modal-thumb-remove" data-img-idx="${idx}">&times;</button>
          </div>`;
      });
      imagesHtml += `
        <div class="modal-add-photo" id="modalAddPhoto">
          <span class="plus">+</span>
          <span>Add Photos</span>
        </div>`;

      // Title block
      let titleBlockHtml = '';
      if (meta.generatedTitle) {
        titleBlockHtml = `
          <div class="modal-title-block">
            <div class="modal-title-label">eBay Title</div>
            <div class="modal-title-row">
              <input type="text" class="modal-title-text" id="modalTitleInput" value="${escapeHtml(meta.generatedTitle)}" maxlength="80">
              <span class="modal-title-charcount" id="modalTitleCount">${meta.generatedTitle.length}/80</span>
              <button class="copy-btn" id="modalCopyTitle">Copy</button>
            </div>
          </div>
        `;
      }

      // Description block
      let descBlockHtml = '';
      if (meta.generatedHtml) {
        descBlockHtml = `
          <div class="modal-desc-block">
            <div class="modal-desc-tabs">
              <button class="modal-desc-tab active" data-tab="preview">Preview</button>
              <button class="modal-desc-tab" data-tab="edit">Edit HTML</button>
              <span style="flex:1;"></span>
              <button class="copy-btn" style="margin:6px 8px;" id="modalCopyHtml">Copy HTML</button>
            </div>
            <div class="modal-desc-preview" id="modalDescPreview">${meta.generatedHtml}</div>
            <div class="modal-desc-edit" id="modalDescEdit"><textarea id="modalDescTextarea">${escapeHtml(meta.generatedHtml)}</textarea></div>
          </div>
        `;
      }

      // Fields
      const fieldsHtml = `
        <div class="modal-fields">
          <div class="modal-field">
            <label>Category</label>
            <div class="cat-autocomplete" id="catAutocomplete">
              <div class="cat-selected" id="catSelected" style="${meta.suggestedCategoryId ? '' : 'display:none'}">
                <span class="cat-name" id="catSelectedName">${escapeHtml(meta.suggestedCategoryName || '')}</span>
                <span class="cat-id" id="catSelectedId">${escapeHtml(meta.suggestedCategoryId || '')}</span>
                <button class="cat-clear" id="catClearBtn">&times;</button>
              </div>
              <input type="text" id="modalCatSearch" placeholder="Search eBay categories..." autocomplete="off">
              <input type="hidden" id="modalCatId" value="${escapeHtml(meta.suggestedCategoryId || '')}">
              <input type="hidden" id="modalCatName" value="${escapeHtml(meta.suggestedCategoryName || '')}">
              <div class="cat-dropdown" id="catDropdown"></div>
            </div>
          </div>
          <div id="aspectsContainer" style="grid-column: 1 / -1;"></div>
          <div class="modal-field">
            <label>Custom Label (SKU)</label>
            <input type="text" id="modalSku" value="${escapeHtml(meta._sku || '')}" placeholder="e.g. ABC-12345" maxlength="50">
          </div>
          <div class="modal-field">
            <label>Quantity</label>
            <input type="number" id="modalQty" value="1" min="1" step="1">
          </div>
          <div class="modal-field">
            <label>Shipping Policy</label>
            <select id="modalShipPolicy">${shipOptions}</select>
          </div>
          <div class="modal-field">
            <label>Return Policy</label>
            <select id="modalRetPolicy">${retOptions}</select>
          </div>

          <div class="offers-section">
            <div class="offers-section-title">Offers &amp; Promotions</div>
            <div class="offers-grid">
              <div class="offer-toggle">
                <label><input type="checkbox" id="modalBestOffer" ${meta._bestOfferEnabled ? 'checked' : ''}> Allow Best Offers</label>
              </div>
              <div class="offer-toggle">
                <label><input type="checkbox" id="modalAutoPay" ${meta._autoPay !== false ? 'checked' : ''}> Require Immediate Payment</label>
              </div>
              <div class="offer-sub-fields ${meta._bestOfferEnabled ? 'open' : ''}" id="bestOfferSubFields">
                <div class="modal-field">
                  <label>Auto-Accept Price ($)</label>
                  <input type="number" id="modalAutoAcceptPrice" value="${meta._autoAcceptPrice || ''}" min="0" step="0.01" placeholder="Accept offers at or above">
                  <div class="offer-hint">Offers at or above this price are automatically accepted</div>
                </div>
                <div class="modal-field">
                  <label>Auto-Decline Price ($)</label>
                  <input type="number" id="modalMinBestOfferPrice" value="${meta._minBestOfferPrice || ''}" min="0" step="0.01" placeholder="Decline offers below">
                  <div class="offer-hint">Offers below this price are automatically declined</div>
                </div>
              </div>
            </div>
          </div>
        </div>
      `;

      modalBody.innerHTML = `
        <div style="font-size:11px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:#8b8fa3;margin-bottom:6px;">Product Images</div>
        <div class="modal-images" id="modalImages">${imagesHtml}</div>
        <input type="file" id="modalFileInput" accept="image/*" multiple style="display:none;">
        ${titleBlockHtml}
        ${descBlockHtml}
        ${fieldsHtml}
      `;

      // Footer
      if (meta.status === 'listed') {
        modalFooter.innerHTML = `
          <span class="modal-status">Listed as <a href="https://www.ebay.com/itm/${meta.ebayItemId}" target="_blank">#${meta.ebayItemId}</a></span>
          <span class="spacer"></span>
          <button class="btn btn-secondary btn-sm" onclick="closeModal()">Close</button>
        `;
      } else if (meta.status === 'ready') {
        modalFooter.innerHTML = `
          <button class="btn btn-green btn-sm" id="modalListBtn">Publish</button>
          <button class="btn btn-red btn-xs" id="modalRejectBtn">Reject</button>
          <span class="modal-status" id="modalStatus"></span>
          <span class="spacer"></span>
          <button class="btn btn-secondary btn-sm" id="modalSaveBtn">Save & Close</button>
        `;
      } else {
        modalFooter.innerHTML = `
          <span class="spacer"></span>
          <button class="btn btn-secondary btn-sm" onclick="closeModal()">Close</button>
        `;
      }

      modalOverlay.classList.add('open');

      // ── Image upload events ──
      const addPhotoBtn = document.getElementById('modalAddPhoto');
      const modalFileInput = document.getElementById('modalFileInput');
      if (addPhotoBtn && modalFileInput) {
        addPhotoBtn.addEventListener('click', () => modalFileInput.click());
        modalFileInput.addEventListener('change', () => {
          handleModalFiles(ci, modalFileInput.files);
          modalFileInput.value = '';
        });
      }

      // Image remove buttons
      document.querySelectorAll('.modal-thumb-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(btn.dataset.imgIdx);
          meta.images.splice(idx, 1);
          refreshModalImages(ci);
          updateRow(ci);
        });
      });

      // Tab switching
      modalBody.querySelectorAll('.modal-desc-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          modalBody.querySelectorAll('.modal-desc-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          const mode = tab.dataset.tab;
          const prev = document.getElementById('modalDescPreview');
          const edit = document.getElementById('modalDescEdit');
          const textarea = document.getElementById('modalDescTextarea');
          if (prev) prev.style.display = mode === 'preview' ? 'block' : 'none';
          if (edit) edit.style.display = mode === 'edit' ? 'block' : 'none';
          if (mode === 'preview' && prev && textarea) {
            prev.innerHTML = textarea.value;
          }
        });
      });

      // Title character counter
      const titleInput = document.getElementById('modalTitleInput');
      const titleCount = document.getElementById('modalTitleCount');
      if (titleInput && titleCount) {
        titleInput.addEventListener('input', () => {
          titleCount.textContent = `${titleInput.value.length}/80`;
          titleCount.style.color = titleInput.value.length > 80 ? '#ef4444' : '#8b8fa3';
        });
      }

      // Copy buttons
      const copyTitle = document.getElementById('modalCopyTitle');
      if (copyTitle) copyTitle.addEventListener('click', () => {
        const val = document.getElementById('modalTitleInput')?.value || meta.generatedTitle;
        copyText(copyTitle, val);
      });

      const copyHtml = document.getElementById('modalCopyHtml');
      if (copyHtml) copyHtml.addEventListener('click', () => {
        const val = document.getElementById('modalDescTextarea')?.value || meta.generatedHtml;
        copyText(copyHtml, val);
      });

      // Best Offer toggle
      const bestOfferCb = document.getElementById('modalBestOffer');
      const bestOfferSub = document.getElementById('bestOfferSubFields');
      if (bestOfferCb && bestOfferSub) {
        bestOfferCb.addEventListener('change', () => {
          bestOfferSub.classList.toggle('open', bestOfferCb.checked);
          if (!bestOfferCb.checked) {
            const aa = document.getElementById('modalAutoAcceptPrice');
            const md = document.getElementById('modalMinBestOfferPrice');
            if (aa) aa.value = '';
            if (md) md.value = '';
          }
        });
      }

      // Category autocomplete
      initCategoryAutocomplete(meta);

      // Load item aspects if category already selected
      if (meta.suggestedCategoryId) {
        loadItemAspects(meta.suggestedCategoryId, meta);
      }

      // Save & Close
      const saveBtn = document.getElementById('modalSaveBtn');
      if (saveBtn) saveBtn.addEventListener('click', () => {
        saveModalFields(ci);
        closeModal();
      });

      // List on eBay from modal
      const modalListBtn = document.getElementById('modalListBtn');
      if (modalListBtn) modalListBtn.addEventListener('click', async () => {
        saveModalFields(ci);
        closeModal();
        await listOnEbay(ci);
      });

      // Reject from modal
      const modalRejectBtn = document.getElementById('modalRejectBtn');
      if (modalRejectBtn) modalRejectBtn.addEventListener('click', () => {
        rejectListing(ci);
        closeModal();
      });
    }

    function handleModalFiles(ci, files) {
      const meta = products[ci];
      let loaded = 0;
      const total = files.length;
      for (const file of files) {
        if (!file.type.startsWith('image/')) continue;
        const reader = new FileReader();
        reader.onload = (e) => {
          const dataUrl = e.target.result;
          const base64 = dataUrl.split(',')[1];
          meta.images.push({ file, dataUrl, base64 });
          loaded++;
          if (loaded >= total) {
            refreshModalImages(ci);
            updateRow(ci);
          }
        };
        reader.readAsDataURL(file);
      }
    }

    function refreshModalImages(ci) {
      const meta = products[ci];
      const container = document.getElementById('modalImages');
      if (!container) return;

      let html = '';
      meta.images.forEach((img, idx) => {
        html += `
          <div class="modal-thumb-wrap" data-img-idx="${idx}">
            <img class="modal-thumb" src="${img.dataUrl}" alt="">
            <button class="modal-thumb-remove" data-img-idx="${idx}">&times;</button>
          </div>`;
      });
      html += `
        <div class="modal-add-photo" id="modalAddPhoto">
          <span class="plus">+</span>
          <span>Add Photos</span>
        </div>`;
      container.innerHTML = html;

      // Re-attach events
      const addPhotoBtn = document.getElementById('modalAddPhoto');
      const modalFileInput = document.getElementById('modalFileInput');
      if (addPhotoBtn && modalFileInput) {
        addPhotoBtn.addEventListener('click', () => modalFileInput.click());
      }

      document.querySelectorAll('.modal-thumb-remove').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(btn.dataset.imgIdx);
          meta.images.splice(idx, 1);
          refreshModalImages(ci);
          updateRow(ci);
        });
      });
    }

    function saveModalFields(ci) {
      const meta = products[ci];
      const titleInput = document.getElementById('modalTitleInput');
      const descTextarea = document.getElementById('modalDescTextarea');
      const catId = document.getElementById('modalCatId');
      const sku = document.getElementById('modalSku');
      const qty = document.getElementById('modalQty');
      const ship = document.getElementById('modalShipPolicy');
      const ret = document.getElementById('modalRetPolicy');

      if (titleInput) meta.generatedTitle = titleInput.value.trim();
      if (descTextarea) meta.generatedHtml = descTextarea.value.trim();
      if (catId) meta.suggestedCategoryId = catId.value.trim();
      const catName = document.getElementById('modalCatName');
      if (catName && catName.value.trim()) meta.suggestedCategoryName = catName.value.trim();
      meta._itemAspects = collectAspects();
      meta.suggestedBrand = meta._itemAspects['Brand'] || meta.brand || '';
      meta.suggestedType = meta._itemAspects['Type'] || '';
      meta.suggestedMpn = meta._itemAspects['MPN'] || meta.mpn || '';
      if (sku) meta._sku = sku.value.trim();
      if (qty) meta._modalQty = qty.value;
      if (ship) meta._shippingPolicyId = ship.value;
      if (ret) meta._returnPolicyId = ret.value;

      // Offers & Promotions
      const bestOfferCb = document.getElementById('modalBestOffer');
      const autoPayCb = document.getElementById('modalAutoPay');
      const autoAccept = document.getElementById('modalAutoAcceptPrice');
      const minOffer = document.getElementById('modalMinBestOfferPrice');
      if (bestOfferCb) meta._bestOfferEnabled = bestOfferCb.checked;
      if (autoPayCb) meta._autoPay = autoPayCb.checked;
      if (autoAccept) meta._autoAcceptPrice = autoAccept.value.trim();
      if (minOffer) meta._minBestOfferPrice = minOffer.value.trim();

      updateRow(ci);
    }

    // ── Category autocomplete ──
    async function initCategoryAutocomplete(meta) {
      const searchInput = document.getElementById('modalCatSearch');
      const dropdown = document.getElementById('catDropdown');
      const selectedDiv = document.getElementById('catSelected');
      const selectedName = document.getElementById('catSelectedName');
      const selectedId = document.getElementById('catSelectedId');
      const clearBtn = document.getElementById('catClearBtn');
      const hiddenId = document.getElementById('modalCatId');
      const hiddenName = document.getElementById('modalCatName');
      if (!searchInput || !dropdown) return;

      let debounceTimer = null;

      function selectCategory(id, name, autoFill = false) {
        hiddenId.value = id;
        hiddenName.value = name;
        selectedName.textContent = name;
        selectedId.textContent = id;
        selectedDiv.style.display = 'flex';
        searchInput.value = '';
        dropdown.classList.remove('open');
        loadItemAspects(id, meta, autoFill);
      }

      clearBtn.addEventListener('click', () => {
        hiddenId.value = '';
        hiddenName.value = '';
        selectedDiv.style.display = 'none';
        searchInput.focus();
      });

      searchInput.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        const q = searchInput.value.trim();
        if (q.length < 2) { dropdown.classList.remove('open'); return; }
        debounceTimer = setTimeout(() => fetchCategories(q), 350);
      });

      async function fetchCategories(q) {
        dropdown.innerHTML = '<div class="cat-dropdown-loading">Searching...</div>';
        dropdown.classList.add('open');
        try {
          const resp = await fetch(`/api/ebay/category-suggestions?q=${encodeURIComponent(q)}`);
          const data = await resp.json();
          if (!data.success || !data.suggestions?.length) {
            dropdown.innerHTML = '<div class="cat-dropdown-loading">No categories found</div>';
            return;
          }
          dropdown.innerHTML = data.suggestions.map(s =>
            `<div class="cat-dropdown-item" data-id="${escapeHtml(s.id)}" data-name="${escapeHtml(s.name)}">
              <div class="cat-item-name">${escapeHtml(s.name)}</div>
              <div class="cat-item-path">${escapeHtml(s.path)}</div>
            </div>`
          ).join('');
          dropdown.querySelectorAll('.cat-dropdown-item').forEach(item => {
            item.addEventListener('click', () => {
              selectCategory(item.dataset.id, item.dataset.name);
            });
          });
        } catch (err) {
          dropdown.innerHTML = `<div class="cat-dropdown-loading" style="color:#ef4444;">${err.message}</div>`;
        }
      }

      document.addEventListener('click', (e) => {
        if (!e.target.closest('#catAutocomplete')) dropdown.classList.remove('open');
      });

      if (!meta.suggestedCategoryId) {
        const q = meta.generatedTitle || meta.productName || '';
        if (q) {
          await fetchCategories(q);
          const firstItem = dropdown.querySelector('.cat-dropdown-item');
          if (firstItem) {
            selectCategory(firstItem.dataset.id, firstItem.dataset.name, true);
          }
        }
      }
    }

    // ── Item Aspects (dynamic per category) ──
    let currentAspects = [];
    let currentAspectsMeta = null;

    async function loadItemAspects(categoryId, meta, autoFill = false) {
      currentAspectsMeta = meta;
      const container = document.getElementById('aspectsContainer');
      if (!container) return;
      container.innerHTML = '<div class="aspects-loading">Loading item specifics...</div>';
      currentAspects = [];

      try {
        const resp = await fetch(`/api/ebay/item-aspects?category_id=${encodeURIComponent(categoryId)}`);
        const data = await resp.json();
        if (!data.success || !data.aspects?.length) {
          container.innerHTML = '';
          return;
        }

        const aspects = data.aspects.sort((a, b) => {
          if (a.required !== b.required) return a.required ? -1 : 1;
          return a.name.localeCompare(b.name);
        });

        const requiredAspects = aspects.filter(a => a.required);
        const recommendedAspects = aspects.filter(a => !a.required).slice(0, Math.max(0, 20 - requiredAspects.length));
        const shownAspects = [...requiredAspects, ...recommendedAspects];
        currentAspects = shownAspects;

        const saved = meta._itemAspects || {};
        if (!saved['Brand'] && meta.brand) saved['Brand'] = meta.suggestedBrand || meta.brand;
        if (!saved['Type'] && meta.suggestedType) saved['Type'] = meta.suggestedType;
        if (!saved['MPN'] && meta.mpn) saved['MPN'] = meta.suggestedMpn || meta.mpn;

        let html = '<div class="aspects-section-title">Item Specifics <button class="aspects-autofill-btn" id="autofillAspectsBtn">Auto-fill with AI</button></div>';
        html += '<div class="modal-fields" style="margin-bottom:0;">';

        for (const asp of shownAspects) {
          const savedVal = saved[asp.name] || '';
          const reqBadge = asp.required ? '<span class="req">*</span>' : '';
          const fieldId = `aspect_${asp.name.replace(/[^a-zA-Z0-9]/g, '_')}`;

          if (asp.values && asp.values.length > 0) {
            const optionsHtml = asp.values.map(v =>
              `<div class="aspect-option" data-val="${escapeHtml(v)}">${escapeHtml(v)}</div>`
            ).join('');
            html += `
              <div class="modal-field">
                <label>${escapeHtml(asp.name)}${reqBadge}</label>
                <div class="aspect-combo">
                  <input type="text" id="${fieldId}" value="${escapeHtml(savedVal)}" placeholder="${asp.required ? 'Required' : 'Optional'}" autocomplete="off" data-aspect="${escapeHtml(asp.name)}">
                  <span class="aspect-arrow">&#9662;</span>
                  <div class="aspect-list" id="${fieldId}_list">${optionsHtml}</div>
                </div>
              </div>`;
          } else {
            html += `
              <div class="modal-field">
                <label>${escapeHtml(asp.name)}${reqBadge}</label>
                <input type="text" id="${fieldId}" value="${escapeHtml(savedVal)}" placeholder="${asp.required ? 'Required' : 'Optional'}" data-aspect="${escapeHtml(asp.name)}">
              </div>`;
          }
        }
        html += '</div>';
        container.innerHTML = html;

        // Wire up combo dropdowns
        container.querySelectorAll('.aspect-combo').forEach(combo => {
          const input = combo.querySelector('input');
          const list = combo.querySelector('.aspect-list');
          const allOptions = list.querySelectorAll('.aspect-option');

          function filterOptions() {
            const q = input.value.toLowerCase();
            let visible = 0;
            allOptions.forEach(opt => {
              const match = opt.dataset.val.toLowerCase().includes(q);
              opt.style.display = match ? '' : 'none';
              if (match) visible++;
            });
            list.classList.toggle('open', visible > 0);
          }

          input.addEventListener('focus', () => { filterOptions(); });
          input.addEventListener('input', () => { filterOptions(); });
          allOptions.forEach(opt => {
            opt.addEventListener('mousedown', (e) => {
              e.preventDefault();
              input.value = opt.dataset.val;
              list.classList.remove('open');
            });
          });
          input.addEventListener('blur', () => {
            setTimeout(() => list.classList.remove('open'), 150);
          });
        });

        // Wire up auto-fill button
        const autofillBtn = document.getElementById('autofillAspectsBtn');
        if (autofillBtn) {
          autofillBtn.addEventListener('click', () => autofillAspects());
        }

        if (autoFill && !meta._itemAspects) {
          autofillAspects();
        }

      } catch (err) {
        container.innerHTML = `<div class="aspects-loading" style="color:#ef4444;">Failed to load item specifics</div>`;
      }
    }

    function collectAspects() {
      const result = {};
      for (const asp of currentAspects) {
        const fieldId = `aspect_${asp.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
        const el = document.getElementById(fieldId);
        if (el && el.value.trim()) {
          result[asp.name] = el.value.trim();
        }
      }
      return result;
    }

    async function autofillAspects() {
      const btn = document.getElementById('autofillAspectsBtn');
      if (!btn || !currentAspectsMeta) return;
      btn.disabled = true;
      btn.textContent = 'Filling...';

      const meta = currentAspectsMeta;
      const productInfo = [
        meta.generatedTitle || meta.productName || '',
        `Brand: ${meta.brand}`,
        `MPN: ${meta.mpn}`,
      ].filter(Boolean).join(' | ');

      const fieldsToFill = currentAspects.map(asp => {
        const fieldId = `aspect_${asp.name.replace(/[^a-zA-Z0-9]/g, '_')}`;
        const el = document.getElementById(fieldId);
        const currentVal = el ? el.value.trim() : '';
        return {
          name: asp.name,
          required: asp.required,
          currentValue: currentVal,
          allowedValues: asp.values && asp.values.length > 0 ? asp.values : null,
        };
      });

      const prompt = `You are filling out eBay item specifics for a product listing. Your job is to pick the BEST matching value for each field.

Product: ${productInfo}

CRITICAL RULES:
1. If a field has "allowedValues", you MUST pick EXACTLY one value from that list — copy it character-for-character. Do NOT invent values.
2. If a field has no allowedValues (null), provide a reasonable text value based on the product.
3. For required fields, ALWAYS provide a value. Use "Does Not Apply" only as a last resort for free-text fields.
4. For fields with allowedValues where you're unsure, pick the closest matching option from the list.
5. If a field already has a "currentValue", keep it unless you have a clearly better match.

Fields:
${JSON.stringify(fieldsToFill, null, 2)}

Respond with ONLY a valid JSON object mapping field names to values. No explanation, no markdown, no code blocks. Just the JSON object.`;

      try {
        const resp = await fetch('/api/openai/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            messages: [{ role: 'user', content: prompt }],
            temperature: 0.3,
            max_completion_tokens: 2000,
          }),
        });
        const data = await resp.json();
        const content = data.choices?.[0]?.message?.content || '';

        let jsonStr = content.trim();
        if (jsonStr.startsWith('```')) {
          jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
        }
        const values = JSON.parse(jsonStr);

        for (const [name, value] of Object.entries(values)) {
          const fieldId = `aspect_${name.replace(/[^a-zA-Z0-9]/g, '_')}`;
          const el = document.getElementById(fieldId);
          if (!el || !value) continue;

          const asp = currentAspects.find(a => a.name === name);
          let finalValue = String(value);

          if (asp && asp.values && asp.values.length > 0) {
            const exact = asp.values.find(v => v.toLowerCase() === finalValue.toLowerCase());
            if (exact) {
              finalValue = exact;
            } else {
              const partial = asp.values.find(v =>
                v.toLowerCase().includes(finalValue.toLowerCase()) ||
                finalValue.toLowerCase().includes(v.toLowerCase())
              );
              if (partial) {
                finalValue = partial;
              } else {
                finalValue = asp.values[0];
              }
            }
          }

          if (!el.value.trim()) {
            el.value = finalValue;
          }
        }

      } catch (err) {
        console.error('Auto-fill error:', err);
        alert('Auto-fill failed: ' + (err.message || 'Unknown error'));
      }

      btn.disabled = false;
      btn.textContent = 'Auto-fill with AI';
    }

    // ── Headless aspect prefill (runs during Generate, no modal needed) ──
    async function prefillItemAspects(meta) {
      const aspectResp = await fetch(`/api/ebay/item-aspects?category_id=${encodeURIComponent(meta.suggestedCategoryId)}`);
      const aspectData = await aspectResp.json();
      if (!aspectData.success || !aspectData.aspects?.length) return;

      const aspects = aspectData.aspects.sort((a, b) => {
        if (a.required !== b.required) return a.required ? -1 : 1;
        return a.name.localeCompare(b.name);
      });
      const requiredAspects = aspects.filter(a => a.required);
      const recommendedAspects = aspects.filter(a => !a.required).slice(0, Math.max(0, 20 - requiredAspects.length));
      const shownAspects = [...requiredAspects, ...recommendedAspects];

      const productInfo = [
        meta.generatedTitle || meta.productName || '',
        `Brand: ${meta.brand}`,
        `MPN: ${meta.mpn}`,
      ].filter(Boolean).join(' | ');

      const existing = meta._itemAspects || {};
      if (!existing['Brand'] && meta.brand) existing['Brand'] = meta.suggestedBrand || meta.brand;
      if (!existing['Type'] && meta.suggestedType) existing['Type'] = meta.suggestedType;
      if (!existing['MPN'] && meta.mpn) existing['MPN'] = meta.suggestedMpn || meta.mpn;

      const fieldsToFill = shownAspects.map(asp => ({
        name: asp.name,
        required: asp.required,
        currentValue: existing[asp.name] || '',
        allowedValues: asp.values && asp.values.length > 0 ? asp.values : null,
      }));

      const prompt = `You are filling out eBay item specifics for a product listing. Your job is to pick the BEST matching value for each field.

Product: ${productInfo}

CRITICAL RULES:
1. If a field has "allowedValues", you MUST pick EXACTLY one value from that list — copy it character-for-character. Do NOT invent values.
2. If a field has no allowedValues (null), provide a reasonable text value based on the product.
3. For required fields, ALWAYS provide a value. Use "Does Not Apply" only as a last resort for free-text fields.
4. For fields with allowedValues where you're unsure, pick the closest matching option from the list.
5. If a field already has a "currentValue", keep it unless you have a clearly better match.

Fields:
${JSON.stringify(fieldsToFill, null, 2)}

Respond with ONLY a valid JSON object mapping field names to values. No explanation, no markdown, no code blocks. Just the JSON object.`;

      const resp = await fetch('/api/openai/chat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          messages: [{ role: 'user', content: prompt }],
          temperature: 0.3,
          max_completion_tokens: 2000,
        }),
      });
      const data = await resp.json();
      const content = data.choices?.[0]?.message?.content || '';

      let jsonStr = content.trim();
      if (jsonStr.startsWith('```')) {
        jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '');
      }
      const values = JSON.parse(jsonStr);

      const result = {};
      for (const asp of shownAspects) {
        let val = values[asp.name] ? String(values[asp.name]) : (existing[asp.name] || '');
        if (!val) continue;

        if (asp.values && asp.values.length > 0) {
          const exact = asp.values.find(v => v.toLowerCase() === val.toLowerCase());
          if (exact) {
            val = exact;
          } else {
            const partial = asp.values.find(v =>
              v.toLowerCase().includes(val.toLowerCase()) ||
              val.toLowerCase().includes(v.toLowerCase())
            );
            val = partial || asp.values[0];
          }
        }
        result[asp.name] = val;
      }

      meta._itemAspects = result;
      meta.suggestedBrand = result['Brand'] || meta.suggestedBrand || meta.brand || '';
      meta.suggestedType = result['Type'] || meta.suggestedType || '';
      meta.suggestedMpn = result['MPN'] || meta.suggestedMpn || meta.mpn || '';
    }

    function copyText(btn, text) {
      navigator.clipboard.writeText(text).then(() => {
        const orig = btn.textContent;
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => { btn.textContent = orig; btn.classList.remove('copied'); }, 2000);
      });
    }

    // ═══════════════════════════════════════
    //  Reject
    // ═══════════════════════════════════════
    function rejectListing(ci) {
      products[ci].rejected = true;
      products[ci].status = 'rejected';
      updateRow(ci);
    }

    // ═══════════════════════════════════════
    //  eBay listing
    // ═══════════════════════════════════════

    // Fetch seller policies once
    let sellerPolicies = null;
    async function ensurePolicies() {
      if (sellerPolicies) return sellerPolicies;
      try {
        const resp = await fetch('/api/ebay/policies');
        sellerPolicies = await resp.json();
      } catch (e) {
        sellerPolicies = { shipping: [], returnPolicies: [] };
      }
      return sellerPolicies;
    }

    async function listOnEbay(ci) {
      const meta = products[ci];

      const price = document.getElementById(`price-${ci}`).value;
      const conditionId = document.getElementById(`condition-${ci}`).value;
      const skuEl = document.getElementById(`sku-${ci}`);
      const sku = (skuEl ? skuEl.value.trim() : '') || meta._sku || '';
      const categoryId = meta.suggestedCategoryId || '';
      const quantity = meta._modalQty || '1';
      const itemSpecifics = meta._itemAspects || {};
      if (!itemSpecifics['Brand'] && meta.brand) itemSpecifics['Brand'] = meta.suggestedBrand || meta.brand;
      if (!itemSpecifics['Type'] && meta.suggestedType) itemSpecifics['Type'] = meta.suggestedType;
      if (!itemSpecifics['MPN'] && meta.mpn) itemSpecifics['MPN'] = meta.suggestedMpn || meta.mpn;

      const policies = await ensurePolicies();
      const shippingPolicyId = meta._shippingPolicyId || (policies.shipping?.find(s => s.default)?.id || policies.shipping?.[0]?.id || '');
      const returnPolicyId = meta._returnPolicyId || (policies.returnPolicies?.find(r => r.default)?.id || policies.returnPolicies?.[0]?.id || '');

      if (!price || parseFloat(price) <= 0) {
        alert(`Please enter a price for "${meta.generatedTitle || meta.productName}"`);
        return;
      }
      if (!categoryId || !/^\d+$/.test(categoryId)) {
        alert(`Please enter a valid category ID. Open Preview for "${meta.generatedTitle || meta.productName}"`);
        return;
      }

      // Safety net: if aspects weren't filled during generate, fill them now
      if (!meta._itemAspects || Object.keys(meta._itemAspects).length === 0) {
        try {
          await prefillItemAspects(meta);
          Object.assign(itemSpecifics, meta._itemAspects || {});
        } catch (e) { console.error('Pre-publish aspect fill failed:', e); }
      }

      meta.status = 'listing';
      updateRow(ci);

      // Upload all images
      const pictureUrls = [];
      const total = meta.images.length;

      for (let i = 0; i < total; i++) {
        meta._listingProgress = `Uploading image ${i + 1}/${total}`;
        const img = meta.images[i];

        try {
          const resp = await fetch('/api/ebay/upload-image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              base64: img.base64,
              filename: img.file.name,
              mimeType: img.file.type
            })
          });
          const data = await resp.json();
          if (data.success) {
            pictureUrls.push(data.url);
          } else {
            throw new Error(data.error || 'Image upload failed');
          }
        } catch (err) {
          meta.status = 'ready';
          updateRow(ci);
          alert(`Image upload error: ${err.message}`);
          return;
        }
      }

      // Create listing
      meta._listingProgress = 'Creating listing...';

      try {
        const resp = await fetch('/api/ebay/add-item', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: meta.generatedTitle,
            description: meta.generatedHtml,
            price,
            categoryId,
            conditionId,
            pictureUrls,
            quantity,
            sku,
            itemSpecifics,
            shippingPolicyId,
            returnPolicyId,
            bestOfferEnabled: meta._bestOfferEnabled || false,
            autoAcceptPrice: meta._autoAcceptPrice || '',
            minBestOfferPrice: meta._minBestOfferPrice || '',
            autoPay: meta._autoPay !== false,
          })
        });
        const data = await resp.json();
        if (data.success) {
          meta.ebayItemId = data.itemId;
          meta.status = 'listed';
        } else {
          throw new Error(data.error || 'Listing failed');
        }
      } catch (err) {
        meta.status = 'ready';
        alert(`Listing error: ${err.message}`);
      }
      updateRow(ci);
    }

    function escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
  </script>
</body>
</html>
